{
  "sources": [
    {
      "title": "null program",
      "feedUrl": "https://nullprogram.com/feed/",
      "siteUrl": "https://nullprogram.com",
      "articles": [
        {
          "id": "https://nullprogram.com/blog/2025/02/17/",
          "author": null,
          "description": "xxd is a versatile hexdump utility with a “reverse” feature, originally\nwritten between 1990–1996. The Vim project soon adopted it, and it’s lived\nthere ever since. If you have Vim, you also have xxd. Its primary use\ncases are (1) the basis for a hex editor due to its -r reverse option\nthat can unhexdump its previous output, and (2) a data embedding tool\nfor C and C++ (-i). The former provides Vim’s rudimentary hex editor\nfunctionality. The second case is of special interest to w64devkit:\nxxd -i appears in many builds that embed arbitrary data. It’s\nimportant that w64devkit has a compatible implementation, and a freshly\nrewritten, improved xxd, rexxd, now replaces the original xxd (as\nxxd).\nFor those unfamiliar with xxd, examples are in order. Its default hexdump\noutput looks like this:\n\n$…",
          "link": "https://nullprogram.com/blog/2025/02/17/",
          "publishedOn": "2025-02-17T00:49:49.000Z",
          "wordCount": 2717,
          "title": "Meet the new xxd for w64devkit: rexxd",
          "imageUrl": null
        },
        {
          "id": "https://nullprogram.com/blog/2025/02/05/",
          "author": null,
          "description": "Fuzz testing is incredibly effective for mechanically discovering software\ndefects, yet remains underused and neglected. Pick any program that must\ngracefully accept complex input, written in any language, which has not\nyet been been fuzzed, and fuzz testing usually reveals at least one bug.\nAt least one program currently installed on your own computer certainly\nqualifies. Perhaps even most of them. Everything is broken and\nlow-hanging fruit is everywhere. After fuzz testing ~1,000 projects over\nthe past six years, I’ve accumulated tips for picking that fruit.\nThe checklist format has worked well in the past (1, 2), so\nI’ll use it again. This article discusses AFL++ on source-available\nC and C++ targets, running on glibc-based Linux distributions, currently\nthe indisputable best fuzzing pl…",
          "link": "https://nullprogram.com/blog/2025/02/05/",
          "publishedOn": "2025-02-05T18:03:55.000Z",
          "wordCount": 2094,
          "title": "Tips for more effective fuzz testing with AFL++",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "Netflix TechBlog - Medium",
      "feedUrl": "https://netflixtechblog.com/feed",
      "siteUrl": "https://netflixtechblog.com?source=rss----2615bd06b42e---4",
      "articles": [
        {
          "id": "https://medium.com/p/e2b67c88c9fb",
          "author": "Netflix Technology Blog",
          "description": "Part 1: Creating the Source of Truth for Impressions",
          "link": "https://netflixtechblog.com/introducing-impressions-at-netflix-e2b67c88c9fb?source=rss----2615bd06b42e---4",
          "publishedOn": "2025-02-15T01:13:20.000Z",
          "wordCount": 3298,
          "title": "Introducing Impressions at Netflix",
          "imageUrl": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*T6tQiUj-VDtyEhd1"
        }
      ]
    },
    {
      "title": "Nim Programming Language",
      "feedUrl": "https://nim-lang.org/feed.xml",
      "siteUrl": "https://nim-lang.org//",
      "articles": [
        {
          "id": "https://nim-lang.org//blog/2025/02/05/nim-222.html",
          "author": null,
          "description": "The Nim Team is happy to announce version 2.2.2, the first patch release for our stable release, Nim 2.2.\nIt comes four months after the 2.2.0 release and it contains 203 commits, bringing bugfixes and improvements.\nIf you’re still on Nim 1.6, take a look at the version 2.0 release article to see all the features you’re missing.\nIf you’ve been using Nim 2.0, the version 2.2 release article shows the improvements available in Nim 2.2.\nInstalling Nim 2.2.2\nCheck out if the package manager of your OS already ships version 2.2.2 or\ninstall it as described here.\nIf you have installed a previous version of Nim using choosenim,\ngetting Nim 2.2.2 is as easy as:\n$ choosenim update self\n$ choosenim update stable\n\nNOTE: Make sure that the version of choosenim you have installed is 0.8.5 or higher, ot…",
          "link": "https://nim-lang.org//blog/2025/02/05/nim-222.html",
          "publishedOn": "2025-02-05T00:00:00.000Z",
          "wordCount": 683,
          "title": "Nim version 2.2.2 released",
          "imageUrl": "https://nim-lang.org/assets/img/twitter_banner.png"
        }
      ]
    },
    {
      "title": null,
      "feedUrl": "https://ayazhafiz.com/feed-rss2.xml",
      "siteUrl": "https://ayazhafiz.com",
      "articles": []
    },
    {
      "title": "matklad",
      "feedUrl": "https://matklad.github.io/feed.xml",
      "siteUrl": "https://matklad.github.io",
      "articles": [
        {
          "id": "https://matklad.github.io/2025/02/23/macos-for-kde-users.html",
          "author": null,
          "description": "I've switched to MacOS after using Linux continuously since 2012 or thereabouts (first Arch, and\nthen, since 2015, NixOS). This post documents my experience.",
          "link": "https://matklad.github.io/2025/02/23/macos-for-kde-users.html",
          "publishedOn": "2025-02-23T00:00:00.000Z",
          "wordCount": 3128,
          "title": "MacOS for KDE Users",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "Hugging Face - Blog",
      "feedUrl": "https://huggingface.co/blog/feed.xml",
      "siteUrl": "https://huggingface.co/blog",
      "articles": []
    },
    {
      "title": "samwho.dev",
      "feedUrl": "https://samwho.dev/rss.xml",
      "siteUrl": "https://samwho.dev/rss.xml",
      "articles": []
    },
    {
      "title": "Posts on abhinavsarkar.net",
      "feedUrl": "https://abhinavsarkar.net/feed.atom",
      "siteUrl": "https://abhinavsarkar.net",
      "articles": []
    },
    {
      "title": "Daniel Lemire's blog",
      "feedUrl": "https://lemire.me/blog/feed/",
      "siteUrl": "https://lemire.me/blog",
      "articles": [
        {
          "id": "https://lemire.me/blog/?p=21905",
          "author": "Daniel Lemire",
          "description": "Jarred Sumner, the main author of the Bun JavaScript engine, commented a few days ago on X that opening many files on macOS could be slow due to thread contention: “your $5,000 computer is only capable of opening 1 file at a time”. I was curious and I decided to test it out. I wrote … Continue reading How fast can you open 1000 files?",
          "link": "https://lemire.me/blog/2025/03/01/how-fast-can-you-open-1000-files/",
          "publishedOn": "2025-03-01T22:41:04.000Z",
          "wordCount": 3329,
          "title": "How fast can you open 1000 files?",
          "imageUrl": null
        },
        {
          "id": "https://lemire.me/blog/?p=21895",
          "author": "Daniel Lemire",
          "description": "Convention computer instructions operate on a single piece of data at once (e.g., they can negate an integer or add two integers). For better performance, CPU vendors add support for SIMD instructions. SIMD stands for Single Instruction, Multiple Data. It is a type of parallel processing where a single operation is executed simultaneously on multiple … Continue reading AVX-512 gotcha: avoid compressing words to memory with AMD Zen 4 processors",
          "link": "https://lemire.me/blog/2025/02/14/avx-512-gotcha-avoid-compressing-words-to-memory-with-amd-zen-4-processors/",
          "publishedOn": "2025-02-14T21:27:29.000Z",
          "wordCount": 3856,
          "title": "AVX-512 gotcha: avoid compressing words to memory with AMD Zen 4 processors",
          "imageUrl": null
        },
        {
          "id": "https://lemire.me/blog/?p=21864",
          "author": "Daniel Lemire",
          "description": "A common operation in software is the copy of a block of memory. In C/C++, we often call the function memcpy for this purpose. But what happens if, while you are copying the data, another thread is modifying either the source or the destination? The result is fundamentally unpredictable and almost surely a programming error. … Continue reading Thread-safe memory copy",
          "link": "https://lemire.me/blog/2025/02/07/thread-safe-memory-copy/",
          "publishedOn": "2025-02-07T23:12:34.000Z",
          "wordCount": 4662,
          "title": "Thread-safe memory copy",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "devever.net/~hl",
      "feedUrl": "https://www.devever.net/~hl/index.feed",
      "siteUrl": "https://www.devever.net/~hl/",
      "articles": []
    },
    {
      "title": "apenwarr",
      "feedUrl": "https://apenwarr.ca/log/rss.php",
      "siteUrl": "https://apenwarr.ca/log/",
      "articles": []
    },
    {
      "title": "home on CuriousCoding",
      "feedUrl": "https://curiouscoding.nl/index.xml",
      "siteUrl": "https://curiouscoding.nl/",
      "articles": [
        {
          "id": "https://curiouscoding.nl/slides/minimizers/",
          "author": null,
          "description": "1 Minimizer schemes\n \n \n \n\n\n\\[\\newcommand{\\order}{\\mathcal{O}}\\]\nMinimizer scheme: Given a window of \\(w\\) k-mers, pick the (leftmost) smallest one\n\naccording to some order \\(\\order_k\\)\n\\(k=1\\), \\(w=5\\):\n\nBCADF \\(\\to\\) [B, C, A, D, F] \\(\\to\\) A\n\\(k=2\\), \\(w=5\\):\n\nCABCAC..... \\(\\to\\) [CA, AB, BC, CA, AC] \\(\\to\\) AB\n.ABCACC.... \\(\\to\\) [AB, BC, CA, AC, CC] \\(\\to\\) AB\n..BCACCX... \\(\\to\\) [BC, CA, AC, CC, CX] \\(\\to\\) AC new\n...CACCXY.. \\(\\to\\) [CA, AC, CC, CX, XY] \\(\\to\\) AC\n....ACCXYZ. \\(\\to\\) [AC, CC, CX, XY, YZ] \\(\\to\\) AC\n.....CCXYZX \\(\\to\\) [CC, CX, XY, YZ, XZ] \\(\\to\\) CC new\n\n\n\n\n\n\n\n\n\n\n 1.1 Minimizer density lower bound\n \n \n \n\n\n\nDensity of minimizer scheme is \\(\\geq 1/\\sigma^k\\):",
          "link": "https://curiouscoding.nl/slides/minimizers/",
          "publishedOn": "2025-02-26T23:00:00.000Z",
          "wordCount": 515,
          "title": "Near-optimal sampling schemes",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/thesis/",
          "author": null,
          "description": "Table of Contents\n1 Abstract\n2 Introduction\n\n2.1 Objectives\n2.2 Challenges\n2.3 List of papers\n2.4 Thesis structure and contributions\n2.5 Personal note\n3 Discussion and conclusion\n\n3.1 Overview\n3.2 Future directions\n3.3 Concluding remarks\n4 Bibliography\n1 Abstract\n \n \n \n\n\n 2 Introduction\n \n \n \n\nSummary.\n2.1 Objectives\n \n \n \n\n\n 2.2 Challenges\n \n \n \n\n\n 2.3 List of papers\n \n \n \n\nPairwise alignment.\nA*PA, Bioinformatics 24.\nGroot Koerkamp, Ragnar, and Pesho Ivanov. 2024. “Exact Global Alignment Using A* with Chaining Seed Heuristic and Match Pruning.” Edited by Tobias Marschall. Bioinformatics 40 (3). https://doi.org/10.1093/bioinformatics/btae032.",
          "link": "https://curiouscoding.nl/posts/thesis/",
          "publishedOn": "2025-02-22T23:00:00.000Z",
          "wordCount": 411,
          "title": "0. Optimal Throughput Bioinformatics",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/pairwise-alignment/",
          "author": null,
          "description": "Table of Contents\n1 Introduction\n\n1.1 Overview\n2 A history of pairwise alignment\n3 Problem statement\n4 Variations on pairwise alignment\n\n4.1 Alignment types\n4.2 Cost Models\n4.3 Minimizing Cost versus Maximizing Score\n5 The classic quadratic DP algorithms\n6 Linear Memory using Divide and Conquer\n7 Dijkstra’s algorithm and A*\n8 Computational volumes and band doubling\n9 Diagonal transition\n10 Subquadratic methods and lower bounds\n11 Parallelism\n12 LCS and Contours\n13 Some tools\n14 Summary\n15 TODO\n\n15.1 A*PA2\n\nSummary/overview/contribs\nNotation\nMethods\nEvaluation\nDiscussion\n15.2 Semi-global alignment\nAttribution\n \nThis chapter is based on two papers:",
          "link": "https://curiouscoding.nl/posts/pairwise-alignment/",
          "publishedOn": "2025-02-21T23:00:00.000Z",
          "wordCount": 9331,
          "title": "1. Pairwise Alignment",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/minimizers/",
          "author": null,
          "description": "Table of Contents\n1 Theory of sampling schemes\n\n1.1 Introduction\n1.2 Overview\n1.3 Theory of sampling schemes\n1.4 Notation\n1.5 Types of sampling schemes\n1.6 Computing the density\n1.7 The density of random minimizers\n1.8 Universal hitting sets\n1.9 Asymptotic results\n1.10 Variants\n2 Lower bounds\n\n2.1 Schleimer et al.’s bound\n2.2 Marçais et al.’s bound\n2.3 Improving and extending Marçais et al.’s bound\n2.4 A near-tight lower bound on the density of forward sampling schemes\n2.5 Discussion\n3 Sampling schemes\n\n3.1 Variants of lexicographic minimizers\n\nEvaluation\n3.2 UHS-inspired schemes\n3.3 Syncmer-based schemes\n3.4 Open-closed minimizer\n\nEvaluation\n3.5 Mod-minimizer\n\nTheoretical density\nEvaluation\n3.6 Discussion\n4 Selection schemes\n\n4.1 Bidirectional anchors\n4.2 Sus-anchors\n\nEvaluation\n4.3 Discussion\n4.4 TODO Discussion\n5 Checks\n1 Theory of sampling schemes\n \n \n \n\n\n \nAttribution\n \nThis chapter is based on three papers:",
          "link": "https://curiouscoding.nl/posts/minimizers/",
          "publishedOn": "2025-02-20T23:00:00.000Z",
          "wordCount": 15329,
          "title": "2. Minimizers and More",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/throughput/",
          "author": null,
          "description": "Table of Contents\n1 Optimizing Compute Bound Code: Random Minimizers\n\n1.1 Avoiding Branch Misses\n1.2 SIMD: Processing In Parallel\n1.3 Instruction Level Parallelism\n1.4 Input Format\n2 Optimizing Memory Bound Code: Minimal Perfect Hashing\n\n2.1 Using Less Memory\n2.2 Reducing Memory Accesses\n2.3 Interleaving Memory Accesses\n2.4 Batching, Streaming, and Prefetching\n3 TODO Writing High Performance Code\n\n3.1 TODO Benchmarking\n3.2 Writing and Optimizing High Performance Code\n3.3 DROP? Performance Metrics\nAttribution\n \nThis part is based on two preprints:",
          "link": "https://curiouscoding.nl/posts/throughput/",
          "publishedOn": "2025-02-19T23:00:00.000Z",
          "wordCount": 2670,
          "title": "3. High Throughput Bioinformatics",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/minimizer-papers/",
          "author": null,
          "description": "Table of Contents\n1 Overview\n2 Introduction\n- Previous reviews\n3 Theory of sampling schemes\n\n3.1 Questions\n3.2 Types of schemes\n3.3 Parameter regimes\n3.4 Different perspectives\n3.5 UHS vs minimizer scheme\n3.6 (Asymptotic) bounds\n3.7 Lower bounds\n4 Minimizer schemes\n\n4.1 Orders\n4.2 UHS-based and search-based schemes\n4.3 Pure schemes\n4.4 Other variants\n\nSelection schemes\nCanonical minimizers\n4.5 Non-overlapping string sets\nThis post is simply a list of brief comments on many papers related to\nminimizers, and forms the basis of /posts/minimizers/.\n1 Overview\n \n \n \n\n\n \nFigure 1: An overview of the papers this post discusses, showing authors and categories of each paper.",
          "link": "https://curiouscoding.nl/posts/minimizer-papers/",
          "publishedOn": "2025-02-16T23:00:00.000Z",
          "wordCount": 2534,
          "title": "Minimizer papers",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/binsearch/",
          "author": null,
          "description": "Table of Contents\n1 Optimizing Binary Search And Interpolation Search\n\n1.1 Problem statement\n1.2 Inspiration and background\n1.3 Benchmarking setup\n2 Binary search\n\n2.1 Branchless search\n2.2 Explicit prefetching\n2.3 Batching\n2.4 A note on power-of-two array sizes\n3 Eytzinger\n\n3.1 Naive implementation\n3.2 Prefetching\n3.3 Branchless Eytzinger\n3.4 Batched Eytzinger\n\n3.4.1 Non-prefetched\n3.4.2 Prefetched\n4 Eytzinger or BinSearch?\n5 Memory efficiency – parallel search and comparison to S-trees\n6 Interpolation search\n7 Conclusion and takeaways\n1 Optimizing Binary Search And Interpolation Search\n \n \n \n\nThis blogpost is a preliminary of the\npost on static\nsearch trees. We will be looking into binary search and how it can be\noptimized using different memory layouts (Eytzinger), branchless\ntechniques and careful use of prefetching. In addition, we will explore\nbatching. Our language of choice will be Rust.",
          "link": "https://curiouscoding.nl/posts/binsearch/",
          "publishedOn": "2025-02-11T23:00:00.000Z",
          "wordCount": 6348,
          "title": "[WIP] Binary search variants and the effects of batching",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/consensus/",
          "author": null,
          "description": "Table of Contents\n1 Consensus\n\n1.1 Consensus-RecSplit\n2 IDEA: Consensus-PtrHash\n3 Tiny pointers and optimal open addressing hash tables\nThese are some thoughts on the Consensus-based MPHF presented in\nLehmann et al. (2025), and how this could be applied to PtrHash:\nLehmann, Hans-Peter, Peter Sanders, Stefan Walzer, and Jonatan Ziegler. 2025. “Combined Search and Encoding for Seeds, with an Application to Minimal Perfect Hashing.” arXiv. https://doi.org/10.48550/ARXIV.2502.05613.\nBelow are also some thoughts on the papers on tiny pointers, used to achieve\nhash tables with load factors very close to 1: Bender et al. (2021), Farach-Colton, Krapivin, and Kuszmaul (2025).",
          "link": "https://curiouscoding.nl/posts/consensus/",
          "publishedOn": "2025-02-11T23:00:00.000Z",
          "wordCount": 1791,
          "title": "Thoughts on Consensus MPHF and tiny pointers",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/ptrhash/",
          "author": null,
          "description": "Table of Contents\nAbstract\n1 Introduction\n2 Related work\n3 PtrHash\n\n3.1 Overview\n3.2 Details\n3.3 Construction\n3.4 Bucket Assignment Functions\n3.5 Remapping using CacheLineEF\n4 Results\n\n4.1 Construction\n\n4.1.1 Bucket Functions\n4.1.2 Tuning Parameters for Construction\n4.1.3 Remap\n4.2 Comparison to Other Methods\n5 Conclusions and Future Work\nAcknowledgements\nFunding\n6 Appendix: Query throughput\n\n6.1 Batching and streaming\n6.2 Evaluation\n6.3 Multi-threaded Throughput\n7 Appendix: Sharding\n\n7.1 Evaluation\n8 Appendix: Evaluating Hash Functions\n\\[\n\\newcommand{\\part}{\\mathsf{part}}\n\\newcommand{\\bucket}{\\mathsf{bucket}}\n\\newcommand{\\slot}{\\mathsf{slot}}\n\\newcommand{\\reduce}{\\mathsf{reduce}}\n\\newcommand{\\h}{\\mathsf{h}}\n\\newcommand{\\hp}{\\mathsf{h}_{\\mathsf{p}}}\n\\newcommand{\\C}{\\mathsf{C}}\n\\newcommand{\\select}{\\mathsf{select}}\n\\newcommand{\\free}{F}\n\\newcommand{\\mphf}{\\mathsf{H_{mphf}}}\n\\]\nThis is my paper on PtrHash. The original development-log can be found here.\nThis paper is also available on arXiv: DOI, PDF:",
          "link": "https://curiouscoding.nl/posts/ptrhash/",
          "publishedOn": "2025-02-02T23:00:00.000Z",
          "wordCount": 11080,
          "title": "PtrHash: Minimal Perfect Hashing at RAM Throughput",
          "imageUrl": null
        }
      ]
    }
  ],
  "cliVersion": "1.15.1"
}