{
  "sources": [
    {
      "title": "null program",
      "feedUrl": "https://nullprogram.com/feed/",
      "siteUrl": "https://nullprogram.com",
      "articles": [
        {
          "id": "https://nullprogram.com/blog/2025/02/05/",
          "author": null,
          "description": "Fuzz testing is incredibly effective for mechanically discovering software\ndefects, yet remains underused and neglected. Pick any program that must\ngracefully accept complex input, written in any language, which has not\nyet been been fuzzed, and fuzz testing usually reveals at least one bug.\nAt least one program currently installed on your own computer certainly\nqualifies. Perhaps even most of them. Everything is broken and\nlow-hanging fruit is everywhere. After fuzz testing ~1,000 projects over\nthe past six years, I’ve accumulated tips for picking that fruit.\nThe checklist format has worked well in the past (1, 2), so\nI’ll use it again. This article discusses AFL++ on source-available\nC and C++ targets, running on glibc-based Linux distributions, currently\nthe best fuzzing platform for C …",
          "link": "https://nullprogram.com/blog/2025/02/05/",
          "publishedOn": "2025-02-05T18:03:55.000Z",
          "wordCount": 2085,
          "title": "Tips for more effective fuzz testing with AFL++",
          "imageUrl": null
        },
        {
          "id": "https://nullprogram.com/blog/2025/01/19/",
          "author": null,
          "description": "This article durably captures my reddit comment showing techniques\nfor std::unordered_map and std::vector equivalents in C programs. The\ncore, important features of these data structures require only a dozen or\nso lines of code apiece. They compile quickly, and tend to run faster in\ndebug builds than release builds of their C++ equivalents. What they\nlack in genericity they compensate in simplicity. Nothing here will be\nnew. Everything has been covered in greater detail previously, which I\nwill reference when appropriate.\nFor a concrete goal, we will build a data structure representing an\nprocess environment, along with related functionality to make it more\ninteresting. That is, we’ll build a string-to-string map.\nAllocator\nThe foundation is our allocator, a simple bump allocator, so\nwe’ll…",
          "link": "https://nullprogram.com/blog/2025/01/19/",
          "publishedOn": "2025-01-19T04:10:33.000Z",
          "wordCount": 2994,
          "title": "Examples of quick hash tables and dynamic arrays in C",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "Netflix TechBlog - Medium",
      "feedUrl": "https://netflixtechblog.com/feed",
      "siteUrl": "https://netflixtechblog.com?source=rss----2615bd06b42e---4",
      "articles": [
        {
          "id": "https://medium.com/p/e2b67c88c9fb",
          "author": "Netflix Technology Blog",
          "description": "Part 1: Creating the Source of Truth for Impressions",
          "link": "https://netflixtechblog.com/introducing-impressions-at-netflix-e2b67c88c9fb?source=rss----2615bd06b42e---4",
          "publishedOn": "2025-02-15T01:13:20.000Z",
          "wordCount": 3298,
          "title": "Introducing Impressions at Netflix",
          "imageUrl": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*T6tQiUj-VDtyEhd1"
        }
      ]
    },
    {
      "title": "Nim Programming Language",
      "feedUrl": "https://nim-lang.org/feed.xml",
      "siteUrl": "https://nim-lang.org//",
      "articles": [
        {
          "id": "https://nim-lang.org//blog/2025/02/05/nim-222.html",
          "author": null,
          "description": "The Nim Team is happy to announce version 2.2.2, the first patch release for our stable release, Nim 2.2.\nIt comes four months after the 2.2.0 release and it contains 203 commits, bringing bugfixes and improvements.\nIf you’re still on Nim 1.6, take a look at the version 2.0 release article to see all the features you’re missing.\nIf you’ve been using Nim 2.0, the version 2.2 release article shows the improvements available in Nim 2.2.\nInstalling Nim 2.2.2\nCheck out if the package manager of your OS already ships version 2.2.2 or\ninstall it as described here.\nIf you have installed a previous version of Nim using choosenim,\ngetting Nim 2.2.2 is as easy as:\n$ choosenim update self\n$ choosenim update stable\n\nNOTE: Make sure that the version of choosenim you have installed is 0.8.5 or higher, ot…",
          "link": "https://nim-lang.org//blog/2025/02/05/nim-222.html",
          "publishedOn": "2025-02-05T00:00:00.000Z",
          "wordCount": 683,
          "title": "Nim version 2.2.2 released",
          "imageUrl": "https://nim-lang.org/assets/img/twitter_banner.png"
        },
        {
          "id": "https://nim-lang.org//blog/2025/01/23/community-survey-results-2024.html",
          "author": null,
          "description": "The Nim community survey 2024 has been open for two months, and we have received 367 responses – less than in previous years, but we’ll still try to draw conclusions about our users and their habits.\nBefore we go into details, we would like to thank all the people who took the time to respond.\nWe really appreciate the feedback!\nThe goal of this survey was primarily to determine how our community is using Nim, in order to better understand how we should be improving it.\nDo you use Nim?\nBased on the answer to this question, the respondents were divided into two groups that each received a separate set of questions.\n\nApproximately three quarters of the respondents use Nim (40% frequently, 36% occasionally), while the remaining quarter is divided between people who never used Nim (7%) and peop…",
          "link": "https://nim-lang.org//blog/2025/01/23/community-survey-results-2024.html",
          "publishedOn": "2025-01-23T00:00:00.000Z",
          "wordCount": 1078,
          "title": "Nim Community Survey 2024 Results",
          "imageUrl": "https://nim-lang.org/assets/img/twitter_banner.png"
        }
      ]
    },
    {
      "title": null,
      "feedUrl": "https://ayazhafiz.com/feed-rss2.xml",
      "siteUrl": "https://ayazhafiz.com",
      "articles": []
    },
    {
      "title": "matklad",
      "feedUrl": "https://matklad.github.io/feed.xml",
      "siteUrl": "https://matklad.github.io",
      "articles": []
    },
    {
      "title": "Hugging Face - Blog",
      "feedUrl": "https://huggingface.co/blog/feed.xml",
      "siteUrl": "https://huggingface.co/blog",
      "articles": []
    },
    {
      "title": "samwho.dev",
      "feedUrl": "https://samwho.dev/rss.xml",
      "siteUrl": "https://samwho.dev/rss.xml",
      "articles": []
    },
    {
      "title": "Posts on abhinavsarkar.net",
      "feedUrl": "https://abhinavsarkar.net/feed.atom",
      "siteUrl": "https://abhinavsarkar.net",
      "articles": [
        {
          "id": "https://abhinavsarkar.net/posts/brainfuck-interpreter/?mtm_campaign=feed",
          "author": null,
          "description": "<p>Writing an interpreter for Brainfuck is almost a rite of passage for any programming language implementer,\nand it’s my turn now. In this post, we’ll write not one but four Brainfuck interpreters in Haskell. Let’s go!</p>",
          "link": "https://abhinavsarkar.net/posts/brainfuck-interpreter/?mtm_campaign=feed",
          "publishedOn": "2025-01-19T00:00:00.000Z",
          "wordCount": 5739,
          "title": "Interpreting Brainfuck in Haskell",
          "imageUrl": "https://abhinavsarkar.net/images/brainfuck-interpreter/preview.png"
        }
      ]
    },
    {
      "title": "Daniel Lemire's blog",
      "feedUrl": "https://lemire.me/blog/feed/",
      "siteUrl": "https://lemire.me/blog",
      "articles": [
        {
          "id": "https://lemire.me/blog/?p=21895",
          "author": "Daniel Lemire",
          "description": "Convention computer instructions operate on a single piece of data at once (e.g., they can negate an integer or add two integers). For better performance, CPU vendors add support for SIMD instructions. SIMD stands for Single Instruction, Multiple Data. It is a type of parallel processing where a single operation is executed simultaneously on multiple … Continue reading AVX-512 gotcha: avoid compressing words to memory with AMD Zen 4 processors",
          "link": "https://lemire.me/blog/2025/02/14/avx-512-gotcha-avoid-compressing-words-to-memory-with-amd-zen-4-processors/",
          "publishedOn": "2025-02-14T21:27:29.000Z",
          "wordCount": 3691,
          "title": "AVX-512 gotcha: avoid compressing words to memory with AMD Zen 4 processors",
          "imageUrl": null
        },
        {
          "id": "https://lemire.me/blog/?p=21864",
          "author": "Daniel Lemire",
          "description": "A common operation in software is the copy of a block of memory. In C/C++, we often call the function memcpy for this purpose. But what happens if, while you are copying the data, another thread is modifying either the source or the destination? The result is fundamentally unpredictable and almost surely a programming error. … Continue reading Thread-safe memory copy",
          "link": "https://lemire.me/blog/2025/02/07/thread-safe-memory-copy/",
          "publishedOn": "2025-02-07T23:12:34.000Z",
          "wordCount": 4683,
          "title": "Thread-safe memory copy",
          "imageUrl": null
        },
        {
          "id": "https://lemire.me/blog/?p=21850",
          "author": "Daniel Lemire",
          "description": "Programmer time is precious. This realization should shape our approach to software development, focusing our efforts on tasks that genuinely contribute to the improvement of our code and the software ecosystem.   What does matter?   Hunting for bugs. I like to add tests, and then even more tests. The time spent building tests should … Continue reading Programmer time and the pitfalls of wasteful work",
          "link": "https://lemire.me/blog/2025/01/30/programmer-time-and-the-pitfalls-of-false-positives/",
          "publishedOn": "2025-01-30T03:02:36.000Z",
          "wordCount": 3662,
          "title": "Programmer time and the pitfalls of wasteful work",
          "imageUrl": null
        },
        {
          "id": "https://lemire.me/blog/?p=21848",
          "author": "Daniel Lemire",
          "description": "Regular expressions, often abbreviated as regex, are a powerful tool for pattern matching within text. For example, the expression \\d*\\.?\\d+ would match a positive number such as 1.1 or 12. If designed and tested with care, regular expressions may be used in mission-critical software. However, their power comes with a risk: it is possible to … Continue reading Regular expressions can blow up!",
          "link": "https://lemire.me/blog/2025/01/25/regular-expressions-can-blow-up/",
          "publishedOn": "2025-01-25T03:53:36.000Z",
          "wordCount": 3370,
          "title": "Regular expressions can blow up!",
          "imageUrl": null
        },
        {
          "id": "https://lemire.me/blog/?p=21836",
          "author": "Daniel Lemire",
          "description": "Your phone probably runs on 64-bit ARM processors. These processors are ubiquitous: they power the Nintendo Switch, they power cloud servers at both Amazon AWS and Microsoft Azure, they power fast laptops, and so forth. ARM processors have special powerful instructions called ARM NEON. They provide a specific type of parallelism called Single instruction, multiple … Continue reading Checking whether an ARM NEON register is zero",
          "link": "https://lemire.me/blog/2025/01/20/checking-whether-an-arm-neon-register-is-zero/",
          "publishedOn": "2025-01-20T01:05:51.000Z",
          "wordCount": 4198,
          "title": "Checking whether an ARM NEON register is zero",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "devever.net/~hl",
      "feedUrl": "https://www.devever.net/~hl/index.feed",
      "siteUrl": "https://www.devever.net/~hl/",
      "articles": []
    },
    {
      "title": "apenwarr",
      "feedUrl": "https://apenwarr.ca/log/rss.php",
      "siteUrl": "https://apenwarr.ca/log/",
      "articles": []
    },
    {
      "title": "home on CuriousCoding",
      "feedUrl": "https://curiouscoding.nl/index.xml",
      "siteUrl": "https://curiouscoding.nl/",
      "articles": [
        {
          "id": "https://curiouscoding.nl/posts/binsearch/",
          "author": null,
          "description": "Table of Contents\n1 Optimizing Binary Search And Interpolation Search\n\n1.1 Problem statement\n1.2 Inspiration and background\n1.3 Benchmarking setup\n2 Baseline\n\n2.1 A note on power-of-two array sizes\n3 Alternative memory layout\n\n3.1 Naive implementation\n3.2 Prefetching\n3.3 Branchless Eytzinger\n3.4 Batched Eytzinger\n\n3.4.1 Non-prefetched\n3.4.2 Prefetched\n4 Eytzinger or BinSearch?\n5 Memory efficiency – parallel search and comparison to B-trees\n6 Interpolation search\n7 Comparing everything on the human genome\n1 Optimizing Binary Search And Interpolation Search\n \n \n \n\nThis blogpost is a preliminary of the\npost on static\nsearch trees. We will be looking into binary search and how it can be\noptimized using different memory layouts (Eytzinger), branchless\ntechniques and careful use of prefetching. In addition, we will explore\nbatching and different implementations of it, some of them using vector\ninstructions. Our language of choice will be Rust.",
          "link": "https://curiouscoding.nl/posts/binsearch/",
          "publishedOn": "2025-02-11T23:00:00.000Z",
          "wordCount": 3491,
          "title": "[WIP] Binary search variants and the effects of batching",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/consensus/",
          "author": null,
          "description": "Table of Contents\n1 Consensus\n\n1.1 Consensus-RecSplit\n2 IDEA: Consensus-PtrHash\n3 Tiny pointers and optimal open addressing hash tables\nThese are some thoughts on the Consensus-based MPHF presented in\nLehmann et al. (2025), and how this could be applied to PtrHash:\nLehmann, Hans-Peter, Peter Sanders, Stefan Walzer, and Jonatan Ziegler. 2025. “Combined Search and Encoding for Seeds, with an Application to Minimal Perfect Hashing.” arXiv. https://doi.org/10.48550/ARXIV.2502.05613.\nBelow are also some thoughts on the papers on tiny pointers, used to achieve\nhash tables with load factors very close to 1: Bender et al. (2021), Farach-Colton, Krapivin, and Kuszmaul (2025).",
          "link": "https://curiouscoding.nl/posts/consensus/",
          "publishedOn": "2025-02-11T23:00:00.000Z",
          "wordCount": 1791,
          "title": "Thoughts on Consensus MPHF and tiny pointers",
          "imageUrl": null
        },
        {
          "id": "https://curiouscoding.nl/posts/ptrhash-paper/",
          "author": null,
          "description": "Table of Contents\nAbstract\n1 Introduction\n2 Related work\n3 PtrHash\n\n3.1 Overview\n3.2 Construction\n3.3 Remapping using CacheLineEF\n3.4 Bucket Assignment Functions\n3.5 Parallel Queries\n3.6 Sharding\n4 Results\n\n4.1 Construction\n\n4.1.1 Bucket Functions\n4.1.2 Tuning Parameters for Construction\n4.1.3 [Appendix?] Remap\n4.1.4 Sharding\n4.2 Query Throughput\n\n4.2.1 [Appendix?] Batching and Streaming\n4.2.2 [Appendix?] Multi-threaded Throughput\n4.3 Comparison to Other Methods\n5 Conclusions and Future Work\nAcknowledgements\nFunding\n6 Appendix\n\n6.1 Rust and Assembly Code for Streaming\n7 DONE Failed Ideas\n8 Appendix\n\n8.1 TODO Choosing the Part Size\n8.2 Input Types and Hash Functions\n9 Graveyard\n\\[\n\\newcommand{\\part}{\\mathsf{part}}\n\\newcommand{\\bucket}{\\mathsf{bucket}}\n\\newcommand{\\slot}{\\mathsf{slot}}\n\\newcommand{\\reduce}{\\mathsf{reduce}}\n\\newcommand{\\h}{\\mathsf{h}}\n\\newcommand{\\hp}{\\mathsf{h}_{\\mathsf{p}}}\n\\newcommand{\\C}{\\mathsf{C}}\n\\newcommand{\\select}{\\mathsf{select}}\n\\newcommand{\\free}{F}\n\\newcommand{\\mphf}{\\mathsf{H_{mphf}}}\n\\]",
          "link": "https://curiouscoding.nl/posts/ptrhash-paper/",
          "publishedOn": "2025-02-02T23:00:00.000Z",
          "wordCount": 11208,
          "title": "PtrHash: Minimal Perfect Hashing at RAM Throughput",
          "imageUrl": null
        }
      ]
    }
  ],
  "cliVersion": "1.15.1"
}