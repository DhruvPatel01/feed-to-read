{
  "sources": [
    {
      "title": "null program",
      "feedUrl": "https://nullprogram.com/feed/",
      "siteUrl": "https://nullprogram.com",
      "articles": [
        {
          "id": "https://nullprogram.com/blog/2023/10/05/",
          "author": null,
          "description": "Previously I presented an arena-friendly hash map applicable to any\nprogramming language where one might use arena allocation. In this third\narticle I present a generic, arena-backed dynamic array. The details are\nspecific to C, as the most appropriate mechanism depends on the language\n(e.g. templates, generics). Just as in the previous two articles, the goal\nis to demonstrate an idea so simple that a full implementation fits on one\nterminal pager screen — a concept rather than a library.\nUnlike a hash map or linked list, a dynamic array — a data buffer with a\nsize that varies during run time — is more difficult to square with arena\nallocation. They’re contiguous by definition, and we cannot resize objects\nin the middle of an arena, i.e. realloc. So while convenient, they come\nwith trade-o…",
          "link": "https://nullprogram.com/blog/2023/10/05/",
          "publishedOn": "2023-10-05T23:05:57.000Z",
          "wordCount": 2078,
          "title": "A simple, arena-backed, generic dynamic array for C",
          "imageUrl": null
        },
        {
          "id": "https://nullprogram.com/blog/2023/09/30/",
          "author": null,
          "description": "My last article had tips for for arena allocation. This next\narticle demonstrates a technique for building bespoke hash maps that\ncompose nicely with arena allocation. In addition, they’re fast, simple,\nand automatically scale to any problem that could reasonably be solved\nwith an in-memory hash map. To avoid resizing — both to better support\narenas and to simplify implementation — they have slightly above average\nmemory requirements. The design, which we’re calling a hash-trie, is the\nresult of fruitful collaboration with NRK, whose sibling article\nincludes benchmarks. It’s my new favorite data structure, and has proven\nincredibly useful. With a couple well-placed acquire/release atomics, we\ncan even turn it into a lock-free concurrent hash map.\nI’ve written before about MSI hash tables, …",
          "link": "https://nullprogram.com/blog/2023/09/30/",
          "publishedOn": "2023-09-30T23:18:40.000Z",
          "wordCount": 2251,
          "title": "An easy-to-implement, arena-friendly hash map",
          "imageUrl": null
        },
        {
          "id": "https://nullprogram.com/blog/2023/09/27/",
          "author": null,
          "description": "This article was discussed on Hacker News.\nOver the past year I’ve refined my approach to arena allocation.\nWith practice, it’s effective, simple, and fast; typically as easy to use\nas garbage collection but without the costs. Depending on need, an\nallocator can weigh just 7–25 lines of code — perfect when lacking a\nruntime. With the core details of my own technique settled, now is a\ngood time to document and share lessons learned. This is certainly not the\nonly way to approach arena allocation, but these are practices I’ve worked\nout to simplify programs and reduce mistakes.\nAn arena is a memory buffer and an offset into that buffer, initially\nzero. To allocate an object, grab a pointer at the offset, advance the\noffset by the size of the object, and return the pointer. There’s a little\nm…",
          "link": "https://nullprogram.com/blog/2023/09/27/",
          "publishedOn": "2023-09-27T03:58:59.000Z",
          "wordCount": 2580,
          "title": "Arena allocator tips and tricks",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "Max Slater",
      "feedUrl": "https://thenumb.at/feed.xml",
      "siteUrl": "https://thenumb.at/",
      "articles": []
    },
    {
      "title": "Netflix TechBlog - Medium",
      "feedUrl": "https://netflixtechblog.com/feed",
      "siteUrl": "https://netflixtechblog.com?source=rss----2615bd06b42e---4",
      "articles": []
    },
    {
      "title": "Nim Programming Language",
      "feedUrl": "https://nim-lang.org/feed.xml",
      "siteUrl": "https://nim-lang.org//",
      "articles": [
        {
          "id": "https://nim-lang.org//blog/2023/09/19/mastering-nim.html",
          "author": null,
          "description": "Discover the secret of Nim!\nThe definite guide on Nim!\nWritten by the inventor himself.\nNow with updated content for version 2.0 which solves the biggest pain point of Nim 1.0, shared memory in a multi-threaded setting.\nPlease have a look at its cover image:\nBut Nim’s logo is a crown!\nWhere is the crown?\nThat’s the secret of Nim!\nSend us your reply to support@nim-lang.org until December 6th 2023.\nAmong the correct answers we will select 3 winners by randomization.\nThe winners will receive a signed hardcover!\n“Mastering Nim” is available here:\namazon.com\namazon.de",
          "link": "https://nim-lang.org//blog/2023/09/19/mastering-nim.html",
          "publishedOn": "2023-09-19T00:00:00.000Z",
          "wordCount": 241,
          "title": "Mastering Nim, 2nd edition",
          "imageUrl": "https://nim-lang.org/assets/img/twitter_banner.png"
        }
      ]
    },
    {
      "title": null,
      "feedUrl": "https://ayazhafiz.com/feed-rss2.xml",
      "siteUrl": "https://ayazhafiz.com",
      "articles": []
    },
    {
      "title": "matklad",
      "feedUrl": "https://matklad.github.io/feed.xml",
      "siteUrl": "https://matklad.github.io",
      "articles": [
        {
          "id": "https://matklad.github.io/2023/10/06/what-is-an-invariant.html",
          "author": null,
          "description": "I extolled the benefits of programming with invariants in a couple of recent posts.\nNaturally, I didn't explain what I think when I write invariant. This post fixes that.",
          "link": "https://matklad.github.io/2023/10/06/what-is-an-invariant.html",
          "publishedOn": "2023-10-06T00:00:00.000Z",
          "wordCount": 2103,
          "title": "What is an Invariant?",
          "imageUrl": null
        },
        {
          "id": "https://matklad.github.io/2023/09/13/comparative-analysis.html",
          "author": null,
          "description": "Most languages provide 6 comparison operators:",
          "link": "https://matklad.github.io/2023/09/13/comparative-analysis.html",
          "publishedOn": "2023-09-13T00:00:00.000Z",
          "wordCount": 594,
          "title": "Comparative Analysis",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "Hugging Face - Blog",
      "feedUrl": "https://huggingface.co/blog/feed.xml",
      "siteUrl": "https://huggingface.co/blog",
      "articles": []
    },
    {
      "title": "samwho.dev",
      "feedUrl": "https://samwho.dev/rss.xml",
      "siteUrl": "https://samwho.dev/rss.xml",
      "articles": []
    },
    {
      "title": "Posts on abhinavsarkar.net",
      "feedUrl": "https://abhinavsarkar.net/feed.atom",
      "siteUrl": "https://abhinavsarkar.net/feed.atom",
      "articles": []
    },
    {
      "title": "Daniel Lemire's blog",
      "feedUrl": "https://lemire.me/blog/feed/",
      "siteUrl": "https://lemire.me/blog",
      "articles": [
        {
          "id": "https://lemire.me/blog/?p=20845",
          "author": "Daniel Lemire",
          "description": "There are many popular frameworks for writing little web applications. Go and JavaScript (Node.js) are among the most popular choices. Reportedly, Netflix runs on Node.js; Uber moved from Node.js to Go for better performance. There are also less popular options such as Nim. An in-depth review of their performance characteristics would be challenging.  But I … Continue reading Web server ‘hello world’ benchmark : Go vs Node.js vs Nim vs Bun",
          "link": "https://lemire.me/blog/2023/10/07/web-server-hello-world-benchmark-go-vs-node-js-vs-nim-vs-bun/",
          "publishedOn": "2023-10-07T05:43:25.000Z",
          "wordCount": 4621,
          "title": "Web server ‘hello world’ benchmark : Go vs Node.js vs Nim vs Bun",
          "imageUrl": "https://lemire.me/img/portrait2018facebook.jpg"
        },
        {
          "id": "https://lemire.me/blog/?p=20836",
          "author": "Daniel Lemire",
          "description": "If I give a programmer a string such as \"9223372036854775808\" and I ask them to convert it to an integer, they might do the following in C++: std::string s = .... uint64_t val; auto [ptr, ec] = std::from_chars(s.data(), s.data() + s.size(), val); if (ec != std::errc()) {} // I have an error ! // val … Continue reading Parsing integers quickly with AVX-512",
          "link": "https://lemire.me/blog/2023/09/22/parsing-integers-quickly-with-avx-512/",
          "publishedOn": "2023-09-22T21:50:14.000Z",
          "wordCount": 4204,
          "title": "Parsing integers quickly with AVX-512",
          "imageUrl": "https://lemire.me/img/portrait2018facebook.jpg"
        },
        {
          "id": "https://lemire.me/blog/?p=20820",
          "author": "Daniel Lemire",
          "description": "In software, we store strings of text as arrays of bytes in memory using one of the Unicode Transformation Formats (UTF), the most popular being UTF-8 and UTF-16. Windows, Java, C# and other systems common languages and systems default on UTF-16, whereas other systems and most of the web relies on UTF-8. There are benefits … Continue reading Transcoding Unicode strings at crazy speeds with AVX-512",
          "link": "https://lemire.me/blog/2023/09/13/transcoding-unicode-strings-at-crazy-speeds-with-avx-512/",
          "publishedOn": "2023-09-13T16:00:30.000Z",
          "wordCount": 3843,
          "title": "Transcoding Unicode strings at crazy speeds with AVX-512",
          "imageUrl": "https://lemire.me/img/portrait2018facebook.jpg"
        }
      ]
    },
    {
      "title": "devever.net/~hl",
      "feedUrl": "https://www.devever.net/~hl/index.feed",
      "siteUrl": "https://www.devever.net/~hl/",
      "articles": []
    },
    {
      "title": "apenwarr",
      "feedUrl": "https://apenwarr.ca/log/rss.php",
      "siteUrl": "https://apenwarr.ca/log/",
      "articles": [
        {
          "id": "https://apenwarr.ca/log/20231006",
          "author": null,
          "description": "A few conversations last week made me realize I use the word “interesting” in an unusual way.\nI rely heavily on mental models. Of course, everyone relies on mental models. But I do it intentionally and I push it extra hard.\nWhat I mean by that is, when I’m making predictions about what will happen next, I mostly don’t look around me and make a judgement based on my immediate surroundings. Instead, I look at what I see, try to match it to something inside my mental model, and then let the mental model extrapolate what “should” happen from there.\nIf this sounds predictably error prone: yes. It is.\nBut it’s also powerful, when used the right way, which I try to do. Here’s my system.\nConfirmation bias\nFirst of all, let’s acknowledge the problem with mental models: confirmation bias. Confirmati…",
          "link": "https://apenwarr.ca/log/20231006",
          "publishedOn": "2023-10-06T20:59:31.000Z",
          "wordCount": 1980,
          "title": "Interesting",
          "imageUrl": null
        }
      ]
    }
  ],
  "cliVersion": "1.15.1"
}