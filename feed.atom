<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>urn:2024-09-08T01:09:45.418Z</id>
    <title>osmos::feed</title>
    <updated>2024-09-08T01:09:45.418Z</updated>
    <generator>osmosfeed 1.15.1</generator>
    <link rel="alternate" href="index.html"/>
    <entry>
        <title type="html"><![CDATA[Try to Fix It One Level Deeper]]></title>
        <id>https://matklad.github.io/2024/09/06/fix-one-level-deeper.html</id>
        <link href="https://matklad.github.io/2024/09/06/fix-one-level-deeper.html"/>
        <updated>2024-09-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[I had a productive day today! I did many different and unrelated things, but they all had the same
unifying theme:]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Giving C++ std::regex a C makeover]]></title>
        <id>https://nullprogram.com/blog/2024/09/04/</id>
        <link href="https://nullprogram.com/blog/2024/09/04/"/>
        <updated>2024-09-04T17:15:07.000Z</updated>
        <summary type="html"><![CDATA[Suppose you’re working in C using one of the major toolchains — that is,
it’s mainly a C++ implementation — and you need regular expressions. You
could integrate a library, but there’s a regex implementation in the C++
standard library included with your compiler, just within reach. As a
resourceful engineer, using an asset already in hand seems prudent. But
it’s a C++ interface, and you’re using C instead of C++ for a reason,
perhaps to avoid dealing with C++. Have no worries. This article is
about wrapping std::regex in a tidy C interface which not only
hides all the C++ machinery, but utterly tames it. It’s not so much
practical as a potpourri of interesting techniques.
If you’d like to skip ahead, here’s the full source up front. Tested with
w64devkit, MSVC cl, and clang-cl: scratch/re…]]></summary>
        <author>
            <name>null program</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Fundamental Law Of Software Dependencies]]></title>
        <id>https://matklad.github.io/2024/09/03/the-fundamental-law-of-dependencies.html</id>
        <link href="https://matklad.github.io/2024/09/03/the-fundamental-law-of-dependencies.html"/>
        <updated>2024-09-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Canonical source code for software should include checksums of the content of all its
dependencies.]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Compressing floating-point numbers quickly by converting them to brain floats]]></title>
        <id>https://lemire.me/blog/?p=21588</id>
        <link href="https://lemire.me/blog/2024/09/02/compressing-floating-point-numbers-quickly-by-converting-them-to-brain-floats/"/>
        <updated>2024-09-02T22:52:28.000Z</updated>
        <summary type="html"><![CDATA[We sometimes have to work a large quantity of floating-point numbers. This volume can be detrimental to performance. Thus we often want to compress these numbers. Large-language models routinely do so. A sensible approach is to convert them to brain floating point numbers. These are 16-bit numbers that are often capable of representing accurately a … Continue reading Compressing floating-point numbers quickly by converting them to brain floats]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Recommending for Long-Term Member Satisfaction at Netflix]]></title>
        <id>https://medium.com/p/ac15cada49ef</id>
        <link href="https://netflixtechblog.com/recommending-for-long-term-member-satisfaction-at-netflix-ac15cada49ef?source=rss----2615bd06b42e---4"/>
        <updated>2024-08-29T01:01:40.000Z</updated>
        <summary type="html"><![CDATA[By Jiangwei Pan, Gary Tang, Henry Wang, and Justin Basilico]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Getting Started with Nix for Haskell]]></title>
        <id>https://abhinavsarkar.net/posts/nix-for-haskell/?mtm_campaign=feed</id>
        <link href="https://abhinavsarkar.net/posts/nix-for-haskell/?mtm_campaign=feed"/>
        <updated>2024-08-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>So, you’ve heard of the new hotness that is <a href="https://nixos.org" target="_blank" rel="noopener">Nix</a>, for creating reproducible and isolated development environments, and want to use it for your new Haskell project? But you are unclear about how to get started? Then this is the guide you are looking for.</p>]]></summary>
        <author>
            <name>Posts on abhinavsarkar.net</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Improve Your Next Experiment by Learning Better Proxy Metrics From Past Experiments]]></title>
        <id>https://medium.com/p/64c786c2a3ac</id>
        <link href="https://netflixtechblog.com/improve-your-next-experiment-by-learning-better-proxy-metrics-from-past-experiments-64c786c2a3ac?source=rss----2615bd06b42e---4"/>
        <updated>2024-08-26T15:46:24.000Z</updated>
        <summary type="html"><![CDATA[By Aurélien Bibaut, Winston Chou, Simon Ejdemyr, and Nathan Kallus]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Parsing tiny and very large floating-point values: a programming-language comparison]]></title>
        <id>https://lemire.me/blog/?p=21582</id>
        <link href="https://lemire.me/blog/2024/08/26/parsing-tiny-and-very-large-floating-point-values-a-programming-language-comparison/"/>
        <updated>2024-08-26T15:34:55.000Z</updated>
        <summary type="html"><![CDATA[Most programming languages support floating-point numbers. You typically have the ability to turn a string into a floating-point number. E.g., “3.1416” could be parsed as a number close to pi. However strings typically cannot be represented exactly or at all. For example, “1e-1000” is too small and “1e1000” is too large for even 64-bit floating-point … Continue reading Parsing tiny and very large floating-point values: a programming-language comparison]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Faster random integer generation with batching]]></title>
        <id>https://lemire.me/blog/?p=21566</id>
        <link href="https://lemire.me/blog/2024/08/17/faster-random-integer-generation-with-batching/"/>
        <updated>2024-08-17T02:11:30.000Z</updated>
        <summary type="html"><![CDATA[We often generate random integers. Quite often these numbers must be within an interval: e.g., an integer between 0 and 100. One application is a random shuffle. A standard algorithm for a fair random shuffle is the Knuth algorithm: void shuffle(mytype *storage, uint64_t size) { for (uint64_t i = size; i > 1; i--) { … Continue reading Faster random integer generation with batching]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reflection-based JSON in C++ at Gigabytes per Second]]></title>
        <id>https://lemire.me/blog/?p=21555</id>
        <link href="https://lemire.me/blog/2024/08/13/reflection-based-json-in-c-at-gigabytes-per-second/"/>
        <updated>2024-08-13T16:12:46.000Z</updated>
        <summary type="html"><![CDATA[JSON (JavaScript Object Notation) is a popular format for storing and transmitting data. It uses human-readable text to represent structured data in the form of attribute–value pairs and arrays. E.g., {"age":5, "name":"Daniel", toys:["wooden dog", "little car"]}. Ingesting and producing JSON documents can be a performance bottleneck. Thankfully, a few JSON parsers such as simdjson have … Continue reading Reflection-based JSON in C++ at Gigabytes per Second]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[STD Doesn't Have to Abstract OS IO]]></title>
        <id>https://matklad.github.io/2024/08/12/std-io.html</id>
        <link href="https://matklad.github.io/2024/08/12/std-io.html"/>
        <updated>2024-08-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A short note on what goes into a language's standard library, and what's left for third party
libraries to implement!]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
</feed>