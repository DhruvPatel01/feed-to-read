<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>urn:2025-03-30T01:19:38.375Z</id>
    <title>osmos::feed</title>
    <updated>2025-03-30T01:19:38.375Z</updated>
    <generator>osmosfeed 1.15.1</generator>
    <link rel="alternate" href="index.html"/>
    <entry>
        <title type="html"><![CDATA[Mixing ARM NEON with SVE code for fun and profit]]></title>
        <id>https://lemire.me/blog/?p=21947</id>
        <link href="https://lemire.me/blog/2025/03/29/mixing-arm-neon-with-sve-code-for-fun-and-profit/"/>
        <updated>2025-03-29T01:44:47.000Z</updated>
        <summary type="html"><![CDATA[Most mobile devices use 64-bit ARM processors. A growing number of servers (Amazon, Microsoft) also use 64-bit ARM processors. These processors  have special instructions called ARM NEON providing parallelism called Single instruction, multiple data (SIMD). For example, you can compare sixteen values with sixteen other values using one instruction. Some of the most recent ARM … Continue reading Mixing ARM NEON with SVE code for fun and profit]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Foundation Model for Personalized Recommendation]]></title>
        <id>https://medium.com/p/1a0bd8e02d39</id>
        <link href="https://netflixtechblog.com/foundation-model-for-personalized-recommendation-1a0bd8e02d39?source=rss----2615bd06b42e---4"/>
        <updated>2025-03-29T00:51:25.000Z</updated>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a search engine from scratch, in Rust: part 2]]></title>
        <id>https://jdrouet.github.io/posts/202503191700-search-engine-part-2/</id>
        <link href="https://jdrouet.github.io/posts/202503191700-search-engine-part-2/"/>
        <updated>2025-03-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In the previous article, I explained how we'll write on disk and how we'll implement an abstraction so that it works on any device as well as in the browser. Now, it's time to start thinking about what we'll be storing and in what shape.
Defining A Document
In the majority of time, the use of a search engine is coupled with a database, because it's rarely the search-engine responsibility to store the document. The database stores the things and the search-engine indexes the important attributes that need to be searched on. Indexing content is memory intensive so better not abuse it.
The consequence of this it that the document that are being indexed, most of the time, have a defined structure, a schema that they follow.
If we look at an example of search engine like Tantivy, indexing a doc…]]></summary>
        <author>
            <name>jdrouet</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[A Debugger is a REPL is a Debugger]]></title>
        <id>https://matklad.github.io/2025/03/25/debugger-is-repl-is-debugger.html</id>
        <link href="https://matklad.github.io/2025/03/25/debugger-is-repl-is-debugger.html"/>
        <updated>2025-03-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[I love debuggers! The last time I used a debugger seriously was in 2017 or so, when I was still
coding in Kotlin. I've since switched to working with native code, and, sadly gdb and lldb are of
almost no help for me. This is because they are mere debuggers, but what I need is a REPL, and a
debugger, all in one. In this article I show a more productive way to use debuggers as REPLS.]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unsigned comparisons using signed types]]></title>
        <id>https://lemire.me/blog/?p=21930</id>
        <link href="https://lemire.me/blog/2025/03/24/unsigned-comparisons-using-signed-types/"/>
        <updated>2025-03-24T23:24:50.000Z</updated>
        <summary type="html"><![CDATA[There are two main types of fixed-precision integers in modern software: unsigned and signed. In C++20 and above, the signed integers must use the two’s complement convention. Other programming languages typically specify two’s complement as well. Two’s complement is a method for representing signed integers in binary, where the leftmost bit serves as the sign … Continue reading Unsigned comparisons using signed types]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[HDR10+ Now Streaming on Netflix]]></title>
        <id>https://medium.com/p/c9ab1f4bd72b</id>
        <link href="https://netflixtechblog.com/hdr10-now-streaming-on-netflix-c9ab1f4bd72b?source=rss----2615bd06b42e---4"/>
        <updated>2025-03-24T18:39:15.000Z</updated>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[WIP] Beyond Global Alignment]]></title>
        <id>https://curiouscoding.nl/posts/mapping/</id>
        <link href="https://curiouscoding.nl/posts/mapping/"/>
        <updated>2025-03-23T23:00:00.000Z</updated>
        <summary type="html"><![CDATA[Table of Contents
1 Alignment types, revisited

1.1 Semi-global alignment
1.2 Text searching
1.3 Mapping
2 Semi-global alignment
3 Text searching
4 Mapping

4.1 The cost of chaining

4.1.1 max: Anchored edit distance
4.1.2 diff: gap-cost
4.1.3 dist: seed heuristic
4.1.4 minimap
4.1.5 GCSH: gap-chaining seed heuristic
5 New: A*Map

5.1 Text searching
5.2 Mapping
6 Early idea: Bottom-up match-merging (aka BUMMer?)

6.1 Some previous ideas
6.2 Divide & conquer
6.3 Bottom-up match merging (BUMMer)
7 TODO Benchmarks of simple methods
This is Chapter 5 of my thesis.]]></summary>
        <author>
            <name>home on CuriousCoding</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a search engine from scratch, in Rust: part 1]]></title>
        <id>https://jdrouet.github.io/posts/202503170800-search-engine-part-1/</id>
        <link href="https://jdrouet.github.io/posts/202503170800-search-engine-part-1/"/>
        <updated>2025-03-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In the previous article, I introduced what project we're going to address in the following weeks: how to build a cross-platform search engine with encryption capabilities. Today, we'll have a look at the first technical challenge: how to store things on disk.
You might be thinking that we start with a simple topic, to warm up and get ready for the serious parts. That's both right and wrong at the same time. Writing on the filesystem from a mobile application or a desktop application is an easy task, but doing so in the browser while using the same interface is not as easy as it seems.
And on top of that, we want our storage layer to read and write encrypted files, without compromising too much on performance.
The Storage Challenge
Before diving into search algorithms and indexing, we need …]]></summary>
        <author>
            <name>jdrouet</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Use Long Options in Scripts]]></title>
        <id>https://matklad.github.io/2025/03/21/use-long-options-in-scripts.html</id>
        <link href="https://matklad.github.io/2025/03/21/use-long-options-in-scripts.html"/>
        <updated>2025-03-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Many command line utilities support short form options (-f) and long form options (--force).
Short form is for interactive usage. In scripts, use the long form.]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Comptime Zig ORM]]></title>
        <id>https://matklad.github.io/2025/03/19/comptime-zig-orm.html</id>
        <link href="https://matklad.github.io/2025/03/19/comptime-zig-orm.html"/>
        <updated>2025-03-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This post can be considered an advanced Zig tutorial. I will be covering some of the more unique
aspects of the language, but won't be explaining the easy part. If you haven't read the Zig
Language Reference, you might start there. Additionally,
we will also learn the foundational trick for implementing relational model.]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a search engine from scratch, in Rust: introduction]]></title>
        <id>https://jdrouet.github.io/posts/202503161800-search-engine-intro/</id>
        <link href="https://jdrouet.github.io/posts/202503161800-search-engine-intro/"/>
        <updated>2025-03-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Have you ever wondered how search engines work under the hood? I'm not talking about vector search or anything fancy, but just the good old search engines that could really find what we would look for.
Even though we can already find some articles about how search engine work from a high level, it could be interesting to implement our own and add some constraints to make it fun (and maybe simpler).
The Challenge
Most search engine implementations you'll find online target the server-side. They're great for large-scale applications but don't address the unique challenges of building a search engine that runs directly in your browser, your mobile app or in a desktop app. That's exactly what we're going to tackle: creating a client-side search engine that works seamlessly across platforms. An…]]></summary>
        <author>
            <name>jdrouet</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Speeding up C++ code with template lambdas]]></title>
        <id>https://lemire.me/blog/?p=21917</id>
        <link href="https://lemire.me/blog/2025/03/15/speeding-up-c-code-with-template-lambdas/"/>
        <updated>2025-03-15T17:29:50.000Z</updated>
        <summary type="html"><![CDATA[Let us consider a simple C++ function which divides all values in a range of integers: void divide(std::span<int> i, int d) { for (auto& value : i) { value /= d; } } A division between two integers is one of the most expensive operations you can do over integers: it is much slower than … Continue reading Speeding up C++ code with template lambdas]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[An overview of parallel programming (Go edition)]]></title>
        <id>https://lemire.me/blog/?p=21910</id>
        <link href="https://lemire.me/blog/2025/03/09/an-overview-of-parallel-programming-go-edition/"/>
        <updated>2025-03-09T21:35:41.000Z</updated>
        <summary type="html"><![CDATA[In practice, the software we write runs on several processors. Unfortunately, much of what we take for granted on a single processor becomes false when there are more than one processor. For example, if two processors modify the same piece of memory, what is the state of the memory after the modifications? It is difficult … Continue reading An overview of parallel programming (Go edition)]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[SimdSketch: a fast bucket sketch]]></title>
        <id>https://curiouscoding.nl/posts/simd-sketch/</id>
        <link href="https://curiouscoding.nl/posts/simd-sketch/"/>
        <updated>2025-03-08T23:00:00.000Z</updated>
        <summary type="html"><![CDATA[Table of Contents
1 Jaccard similarity
2 Hash schemes

2.1 MinHash
2.2 $s$-mins sketch
2.3 Bottom-\(s\) sketch
2.4 FracMinHash
2.5 Bucket sketch
2.6 Mod-bucket hash (new?)
2.7 Variants
3 Compressing sketches

3.1 $b$-bit hashing

3.1.1 Accounting for collisions
3.2 HyperMinHash
4 Densification strategies
5 SimdSketch
6 Evaluation

6.1 Setup

6.1.1 Tools
6.1.2 Inputs
6.1.3 Parameters
6.1.4 Metrics
6.2 Raw results
6.3 Correlation
6.4 Comparison speed
6.5 Low-similarity data
7 Discussion
8 TODO / Future work
\[
\newcommand{\sketch}{\mathsf{sketch}}
\]]]></summary>
        <author>
            <name>home on CuriousCoding</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Types of tigs]]></title>
        <id>https://curiouscoding.nl/posts/tigs/</id>
        <link href="https://curiouscoding.nl/posts/tigs/"/>
        <updated>2025-03-08T23:00:00.000Z</updated>
        <summary type="html"><![CDATA[1 De Bruijn graph
 
 
 Link to heading
 

Consider an edge-centric De Bruijn graph, where each edge corresponds to a
k-mer, and nodes are the \(k-1\) overlaps between adjacent k-mers. In the figures,
all edges are directed towards the right.




 2 k-mers
 
 
 Link to heading
 

The goal is now to store all edges / k-mers of the graph efficiently.
A spectrum preserving string set (SPSS) is a set of strings whose k-mers are
the k-mers of the input graph, that does not contain duplicate k-mers (Rahman and Medvedev 2020).]]></summary>
        <author>
            <name>home on CuriousCoding</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[A more robust raw OpenBSD syscall demo]]></title>
        <id>https://nullprogram.com/blog/2025/03/06/</id>
        <link href="https://nullprogram.com/blog/2025/03/06/"/>
        <updated>2025-03-06T02:43:20.000Z</updated>
        <summary type="html"><![CDATA[Ted Unangst published dude, where are your syscalls? on flak
yesterday, with a neat demonstration of OpenBSD’s pinsyscall
security feature, whereby only pre-registered addresses are allowed to
make system calls. Whether it strengthens or weakens security is up for
debate, but regardless it’s an interesting, low-level programming
challenge. The original demo is fragile for multiple reasons, and requires
manually locating and entering addresses for each build. In this article I
show how to fix it. To prove that it’s robust, I ported an entire, real
application to use raw system calls on OpenBSD.
The original program uses ARM64 assembly. I’m a lot more comfortable with
x86-64 assembly, plus that’s the hardware I have readily on hand. So the
assembly language will be different, but all the con…]]></summary>
        <author>
            <name>null program</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Title Launch Observability at Netflix Scale]]></title>
        <id>https://medium.com/p/8efe69ebd653</id>
        <link href="https://netflixtechblog.com/title-launch-observability-at-netflix-scale-8efe69ebd653?source=rss----2615bd06b42e---4"/>
        <updated>2025-03-05T01:24:53.000Z</updated>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Robust Wavefront OBJ model parsing in C]]></title>
        <id>https://nullprogram.com/blog/2025/03/02/</id>
        <link href="https://nullprogram.com/blog/2025/03/02/"/>
        <updated>2025-03-02T23:22:58.000Z</updated>
        <summary type="html"><![CDATA[Wavefront OBJ is a line-oriented, text format for 3D geometry. It’s
widely supported by modeling software, easy to parse, and trivial to emit,
much like Netpbm for 2D image data. Poke around hobby 3D graphics
projects and you’re likely to find a bespoke OBJ parser. While typically
only loading their own model data, so robustness doesn’t much matter, they
usually have hard limitations and don’t stand up to fuzz testing.
This article presents a robust, partial OBJ parser in C with no hard-coded
limitations, written from scratch. Like similar articles, it’s not
really about OBJ but demonstrating some techniques you’ve probably never
seen before.
If you’d like to see the ready-to-run full source: objrender.c.
All images are screenshots of this program.
First let’s establish the requirements. B…]]></summary>
        <author>
            <name>null program</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How fast can you open 1000 files?]]></title>
        <id>https://lemire.me/blog/?p=21905</id>
        <link href="https://lemire.me/blog/2025/03/01/how-fast-can-you-open-1000-files/"/>
        <updated>2025-03-01T22:41:04.000Z</updated>
        <summary type="html"><![CDATA[Jarred Sumner, the main author of the Bun JavaScript engine, commented a few days ago on X that opening many files on macOS could be slow due to thread contention: “your $5,000 computer is only capable of opening 1 file at a time”. I was curious and I decided to test it out. I wrote … Continue reading How fast can you open 1000 files?]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
</feed>