<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>urn:2024-02-11T00:55:28.357Z</id>
    <title>osmos::feed</title>
    <updated>2024-02-11T00:55:28.357Z</updated>
    <generator>osmosfeed 1.15.1</generator>
    <link rel="alternate" href="index.html"/>
    <entry>
        <title type="html"><![CDATA[Window: Live, Constant Time Grep]]></title>
        <id>https://matklad.github.io/2024/02/10/window-live-constant-time-grep.html</id>
        <link href="https://matklad.github.io/2024/02/10/window-live-constant-time-grep.html"/>
        <updated>2024-02-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post, I describe the design of window --- a small
grep-like utility I implemented in 500 lines of Rust. The utility itself is likely not that
interesting --- I bet some greybeared can implement an equivalent in 5 lines of bash. But the
design principles behind it might be interesting --- this small utility manages to combine core
ideas of rust-analyzer and TigerBeetle!]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSON Parsing: Intel Sapphire Rapids versus AMD Zen 4]]></title>
        <id>https://lemire.me/blog/?p=21112</id>
        <link href="https://lemire.me/blog/2024/02/09/json-parsing-intel-sapphire-rapids-versus-amd-zen-4/"/>
        <updated>2024-02-09T19:57:29.000Z</updated>
        <summary type="html"><![CDATA[Intel has release a new generation of server processors (Sapphire Rapids) while the latest AMD technology (Zen 4) is now broadly available. There are extensive comparisons available. Of particular interest is the open benchmark results which assess various aspects of processor speeds, including JSON parsing performance. In these benchmarks, AMD systems appear to dominate. I … Continue reading JSON Parsing: Intel Sapphire Rapids versus AMD Zen 4]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[An improved chkstk function on Windows]]></title>
        <id>https://nullprogram.com/blog/2024/02/05/</id>
        <link href="https://nullprogram.com/blog/2024/02/05/"/>
        <updated>2024-02-05T17:56:05.000Z</updated>
        <summary type="html"><![CDATA[If you’ve spent much time developing with Mingw-w64 you’ve likely seen the
symbol ___chkstk_ms, perhaps in an error message. It’s a little piece of
runtime provided by GCC via libgcc which ensures enough of the stack is
committed for the caller’s stack frame. The “function” uses a custom ABI
and is implemented in assembly. So is the subject of this article, a
slightly improved implementation soon to be included in w64devkit as
libchkstk (-lchkstk).
The MSVC toolchain has an identical (x64) or similar (x86) function named
__chkstk. We’ll discuss that as well, and w64devkit will include x86 and
x64 implementations, useful when linking with MSVC object files. The new
x86 __chkstk in particular is also better than the MSVC definition.
A note on spelling: ___chkstk_ms is spelled with three unde…]]></summary>
        <author>
            <name>null program</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How fast is rolling Karp-Rabin hashing?]]></title>
        <id>https://lemire.me/blog/?p=21109</id>
        <link href="https://lemire.me/blog/2024/02/04/how-fast-is-rolling-karp-rabin-hashing/"/>
        <updated>2024-02-04T20:29:59.000Z</updated>
        <summary type="html"><![CDATA[A hash function maps values (e.g., strings) into a fixed number of strings, typically smaller than the original. It is useful to compare quickly two long strings, for example. Instead of comparing the strings, you may compare the hash values. A simple hash function consists in repeatedly multiplying the hash value by some constant B … Continue reading How fast is rolling Karp-Rabin hashing?]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Computing] The Bootstrapping Exam: Escaping from “Trusting Trust”]]></title>
        <id>https://www.devever.net/~hl/bootstrapping-exam</id>
        <link href="https://www.devever.net/~hl/bootstrapping-exam"/>
        <updated>2024-02-04T11:37:00.000Z</updated>
        <summary type="html"><![CDATA[<div type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p xmlns="http://www.w3.org/1999/xhtml">The following is an “exam”. To my knowledge, nobody has ever passed it, as it
is an  difficult challenge. But I am firmly convinced it is
possible, and it makes for an interesting discussion.<em>extremely</em></p></div></div>]]></summary>
        <author>
            <name>devever.net/~hl</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Hμblog] 37C3 talk recording: Adventures in Reverse Engineering Broadcom NIC Firmware]]></title>
        <id>https://www.devever.net/~hl/u/202402#03a</id>
        <link href="https://www.devever.net/~hl/u/202402#03a"/>
        <updated>2024-02-03T07:31:16.000Z</updated>
        <summary type="html"><![CDATA[<div type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><ul><li><a href="https://media.ccc.de/v/37c3-11781-adventures_in_reverse_engineering_broadcom_nic_firmware">37C3 talk recording: Adventures in Reverse Engineering Broadcom NIC Firmware</a></li></ul><p xmlns="http://www.w3.org/1999/xhtml">For those that missed it, a recording of my talk at 37C3 can be found here.</p></div></div>]]></summary>
        <author>
            <name>devever.net/~hl</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nim Community Survey 2023 Results]]></title>
        <id>https://nim-lang.org//blog/2024/01/31/community-survey-results-2023.html</id>
        <link href="https://nim-lang.org//blog/2024/01/31/community-survey-results-2023.html"/>
        <updated>2024-01-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The Nim community survey 2023 has been open for two months, and we have received 662 responses – we think this is a large enough sample to draw conclusions about our users and their habits.
Before we go into details, we would like to thank all the people who took the time to respond.
We really appreciate the feedback!
The goal of this survey was primarily to determine how our community is using Nim, in order to better understand how we should be improving it.
Do you use Nim?
Based on the answer to this question, the respondents were divided into two groups that each received a separate set of questions.

Approximately three quarters of the respondents use Nim (33% frequently, 40% occasionally), while the remaining quarter is divided between people who never used Nim (10%) and people who st…]]></summary>
        <author>
            <name>Nim Programming Language</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Two handy GDB breakpoint tricks]]></title>
        <id>https://nullprogram.com/blog/2024/01/28/</id>
        <link href="https://nullprogram.com/blog/2024/01/28/"/>
        <updated>2024-01-28T21:56:07.000Z</updated>
        <summary type="html"><![CDATA[Over the past couple months I’ve discovered a couple of handy tricks for
working with GDB breakpoints. I figured these out on my own, and I’ve not
seen either discussed elsewhere, so I really ought to share them.
Continuable assertions
The assert macro in typical C implementations leaves a lot to be
desired, as does raise and abort, so I’ve suggested
alternative definitions that behave better under debuggers:

#define assert(c)  while (!(c)) __builtin_trap()
#define assert(c)  while (!(c)) __builtin_unreachable()
#define assert(c)  while (!(c)) *(volatile int *)0 = 0


Each serves a slightly different purpose but still has the most
important property: Immediately halt the program directly on the defect.
None have an occasionally useful secondary property: Optionally allow the
program to co…]]></summary>
        <author>
            <name>null program</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Computing] I hacked a train toilet]]></title>
        <id>https://www.devever.net/~hl/traintoilet</id>
        <link href="https://www.devever.net/~hl/traintoilet"/>
        <updated>2024-01-28T09:08:00.000Z</updated>
        <summary type="html"><![CDATA[<div type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p xmlns="http://www.w3.org/1999/xhtml">The other day I rode on a Class 800 train in the UK. This is the “Intercity
Express” train designed to replace the venerable HST (Intercity 125 with Mark 3
coaches, a train of which I have many memories and which I will dearly miss).</p></div></div>]]></summary>
        <author>
            <name>devever.net/~hl</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[C23: a slightly better C]]></title>
        <id>https://lemire.me/blog/?p=21097</id>
        <link href="https://lemire.me/blog/2024/01/21/c23-a-slightly-better-c/"/>
        <updated>2024-01-21T19:20:10.000Z</updated>
        <summary type="html"><![CDATA[One of the established and most popular programming languages is the C programming language. It is relatively easy to learn, and highly practical. Maybe surprisingly, the C programming language keeps evolving, slowly and carefully. If you have GCC 13 or LLVM (Clang) 16, you already have a compiler with some of the features from the … Continue reading C23: a slightly better C]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How much memory bandwidth do large Amazon instances offer?]]></title>
        <id>https://lemire.me/blog/?p=21092</id>
        <link href="https://lemire.me/blog/2024/01/18/how-much-memory-bandwidth-do-large-amazon-instances-offer/"/>
        <updated>2024-01-18T15:47:12.000Z</updated>
        <summary type="html"><![CDATA[In my previous post, I described how you can write a C++ program to estimate your read memory bandwidth. It is not very difficult: you allocate a large memory region and you read it as fast as you can. To see how much bandwidth you may have if you use multithreaded applications, you can use … Continue reading How much memory bandwidth do large Amazon instances offer?]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Estimating your memory bandwidth]]></title>
        <id>https://lemire.me/blog/?p=21076</id>
        <link href="https://lemire.me/blog/2024/01/13/estimating-your-memory-bandwidth/"/>
        <updated>2024-01-13T21:00:46.000Z</updated>
        <summary type="html"><![CDATA[One of the limitations of a compute is the memory bandwidth. For the scope of this article, I define “memory bandwidth” as the maximal number of bytes you can bring from memory to the CPU per unit of time. E.g., if your system has 5 GB/s of bandwidth, you can read up to 5 GB … Continue reading Estimating your memory bandwidth]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
</feed>