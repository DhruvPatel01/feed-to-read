<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>urn:2022-12-04T01:03:32.314Z</id>
    <title>osmos::feed</title>
    <updated>2022-12-04T01:03:32.314Z</updated>
    <generator>osmosfeed 1.15.1</generator>
    <link rel="alternate" href="index.html"/>
    <entry>
        <title type="html"><![CDATA[Ready-to-go sample data pipelines with Dataflow]]></title>
        <id>https://medium.com/p/17440a9e141d</id>
        <link href="https://netflixtechblog.com/ready-to-go-sample-data-pipelines-with-dataflow-17440a9e141d?source=rss----2615bd06b42e---4"/>
        <updated>2022-12-04T00:10:21.000Z</updated>
        <summary type="html"><![CDATA[by Jasmine Omeke, Obi-Ike Nwoke, Olek Gorajek]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 3 (Advent of Code 2022)]]></title>
        <id>https://fasterthanli.me/series/advent-of-code-2022/part-3</id>
        <link href="https://fasterthanli.me/series/advent-of-code-2022/part-3"/>
        <updated>2022-12-03T09:50:00.000Z</updated>
        <summary type="html"><![CDATA[<h2>
                            <a id="part-1" class="anchor" href="#part-1">
                                Part 1
                            </a>
                        </h2>
                        
<p>I'm not sure where the <a href="https://adventofcode.com/2022/day/3">day 3 challenge</a> is
going, because the problem statement for the first part is kinda convoluted.</p>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 2 (Advent of Code 2022)]]></title>
        <id>https://fasterthanli.me/series/advent-of-code-2022/part-2</id>
        <link href="https://fasterthanli.me/series/advent-of-code-2022/part-2"/>
        <updated>2022-12-02T16:10:00.000Z</updated>
        <summary type="html"><![CDATA[<h2>
                            <a id="part-1" class="anchor" href="#part-1">
                                Part 1
                            </a>
                        </h2>
                        
<p>In the <a href="https://adventofcode.com/2022/day/2">day 2 challenge</a>, we're playing
Rock Papers Scissors.</p>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 1 (Advent of Code 2022)]]></title>
        <id>https://fasterthanli.me/series/advent-of-code-2022/part-1</id>
        <link href="https://fasterthanli.me/series/advent-of-code-2022/part-1"/>
        <updated>2022-12-02T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>Two years ago, I did part of <a href="/series/advent-of-code-2020">Advent of Code 2020</a>
using the <a href="https://www.rust-lang.org/">Rust</a> language. It was a lot of fun,
so let's try it again!</p>

                        <h2>
                            <a id="the-problem-statement" class="anchor" href="#the-problem-statement">
                                The problem statement
                            </a>
                        </h2>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Russian][Math] Проблема 2000 и модульная арифметика]]></title>
        <id>https://yurichev.org/y2k/</id>
        <link href="https://yurichev.org/y2k/"/>
        <updated>2022-12-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[[Russian][Math] Проблема 2000 и модульная арифметика]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Crypto] Ethereum keystore - what is in it?]]></title>
        <id>https://yurichev.org/eth1/</id>
        <link href="https://yurichev.org/eth1/"/>
        <updated>2022-12-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[[Crypto] Ethereum keystore - what is in it?]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Crypto] Fuzzy password]]></title>
        <id>https://yurichev.org/fuzzy_password/</id>
        <link href="https://yurichev.org/fuzzy_password/"/>
        <updated>2022-11-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[[Crypto] Fuzzy password]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Exploring Neural Graphics Primitives]]></title>
        <id>https://thenumbat.github.io/Neural-Graphics/</id>
        <link href="https://thenumbat.github.io/Neural-Graphics/"/>
        <updated>2022-11-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Neural fields have quickly become an interesting and useful application of machine learning to computer graphics. The fundamental idea is quite straightforward: we can use neural models to represent all sorts of digital signals, including images, light fields, signed distance functions, and volumes. Table of Contents Neural Networks Compression A Basic Network Activations Input Encodings Positional Encoding Instant Neural Graphics Primitives More Applications SDFs NeRFs References Neural Networks This post assumes a basic knowledge of neural networks, but let’s briefly recap how they work. A network with \(n\) inputs and \(m\) outputs approximates a function from \(\mathbb{R}^n \mapsto \mathbb{R}^m\) by feeding its input through a sequence of layers. The simplest type of layer is a fully-connected layer, which encodes an affine transform: \(x \mapsto Ax + b\), where \(A\) is the weight matrix and \(b\) is the bias vector. Layers other than the first (input) and last (output) are considered hidden layers, and can have arbitrary dimension. Each hidden layer is followed by applying a non-linear function \(x \mapsto f(x)\), known as the activation. This additional function enables the network to encode non-linear behavior. For example, a network from \(\mathbb{R}^3 \mapsto \mathbb{R}^3\), including two hidden layers of dimensions 5 and 4, can be visualized as follows. The connections between nodes represent weight matrix entries: Or equivalently in symbols (with dimensions): \[\begin{align*} h_{1(5)} &amp;= f(A_{1(5\times3)}x_{(3)} + b_{1(5)})\\ h_{2(4)} &amp;= f(A_{2(4\times5)}h_{1(5)} + b_{2(4)})\\ y_{(3)} &amp;= A_{3(3\times4)}h_{2(4)} + b_{3(3)} \end{align*}\] This network has \(5\cdot3 + 5 + 4\cdot5 + 4 + 3\cdot4 + 3 = 59\) parameters that define its weight matrices and bias vectors. The process of training finds values for these parameters such that the network approximates another function \(g(x)\). Suitable parameters are typically found via stochastic gradient descent. Training requires a loss function measuring how much \(\text{NN}(x)\) differs from \(g(x)\) for all \(x\) in a training set. In practice, we might not know \(g\): given a large number of input-output pairs (e.g. images and their descriptions), we simply perform training and hope that the network will faithfully approximate \(g\) for inputs outside of the training set, too. We’ve only described the most basic kind of neural network: there’s a whole world of possibilities for new layers, activations, loss functions, optimization algorithms, and training paradigms. However, the fundamentals will suffice for this post. Compression When generalization is the goal, neural networks are typically under-constrained: they include far more parameters than strictly necessary to encode a function mapping the training set to its corresponding results. Through regularization, the training process hopes to use these ‘extra’ degrees of freedom to approximate the behavior of \(g\) outside the training set. However, insufficient regularization makes the network vulnerable to over-fitting—it may become extremely accurate on the training set, yet unable to handle new inputs. For this reason, researchers always evaluate neural networks on a test set of known data points that are excluded from the training process. However, in this post we’re actually going to optimize for over-fitting! Instead of approximating \(g\) on new inputs, we will only care about reproducing the right results on the training set. This approach allows us to use over-constrained networks for (lossy) data compression. Let’s say we have some data we want to compress into a neural network. If we can parameterize the input by assigning each value a unique identifier, that gives us a training set. For example, we could parameterize a list of numbers by their index: \[[1, 1, 2, 5, 15, 52, 203] \mapsto \{ (0,1), (1,1), (2,2), (3,5), (4,15), (5,52), (6,203) \}\] …and train a network to associate the index \(n\) with the value \(a[n]\). To do so, we can simply define a loss function that measures the squared error of the result: \((\text{NN}(n) - a[n])^2\). We only care that the network produces \(a[n]\) for \(n\) in 0 to 6, so we want to “over-fit” as much as possible. But, where’s the compression? If we make the network itself smaller than the data set—while being able to reproduce it—we can consider the network to be a compressed encoding of the data. For example, consider this photo of a numbat: Perth Zoo The image consists of 512x512 pixels with three channels (r,g,b) each. Hence, we could naively say it contains 786,432 parameters. If a network with fewer parameters can reproduce it, the network itself can be considered a compressed version of the image. More rigorously, each pixel can be encoded in 3 bytes of data, so we’d want to be able to store the network in fewer than 768 kilobytes—but reasoning about size on-disk would require getting into the weeds of mixed precision networks, so let’s only consider parameter count for now. A Basic Network Let’s train a network to encode the numbat. To create the data set, we will associate each pixel with its corresponding \(x,y\) coordinate. That means our training set will consist of 262,144 examples of the form \((x,y) \mapsto (r,g,b)\). Before training, we’ll normalize the values such that \(x,y \in [-1,1]\) and \(r,g,b \in [0,1]\). \[\begin{align*} (-1.0000,-1.0000) &amp;\mapsto (0.3098, 0.3686, 0.2471)\\ (-1.0000, -0.9961) &amp;\mapsto (0.3059, 0.3686, 0.2471)\\ &amp;\vdots\\ (0.9961, 0.9922) &amp;\mapsto (0.3333, 0.4157, 0.3216)\\ (0.9961, 0.9961) &amp;\mapsto (0.3412, 0.4039, 0.3216) \end{align*}\] Clearly, our network will need to be a function from \(\mathbb{R}^2 \mapsto \mathbb{R}^3\), i.e. have two inputs and three outputs. Just going off intuition, we might include three hidden layers of dimension 128. This architecture will only have 33,795 parameters—far fewer than the image itself. \[\mathbb{R}^2 \mapsto_{fc} \mathbb{R}^{128} \mapsto_{fc} \mathbb{R}^{128} \mapsto_{fc} \mathbb{R}^{128} \mapsto_{fc} \mathbb{R}^3\] Our activation function will be the standard non-linearity ReLU (rectified linear unit). Note that we only want to apply the activation after each hidden layer: we don’t want to clip our inputs or outputs by making them positive. \[\text{ReLU}(x) = \max\{x, 0\}\] Finally, our loss function will be the mean squared error between the network output and the expected color: \[\text{Loss}(x,y) = (\text{NN}(x,y) - \text{Image}_{xy})^2\] Now, let’s train. We’ll do 100 passes over the full data set (100 epochs) with a batch size of 1024. After training, we’ll need some way to evaluate how well the network encoded our image. Hopefully, the network will now return the proper color given a pixel coordinate, so we can re-generate our image by simply evaluating the network at each pixel coordinate in the training set and normalizing the results. And, what do we get? After a bit of hyperparameter tweaking (learning rate, optimization schedule, epochs), we get… Epochs: 100 Well, that sort of worked—you can see the numbat taking shape. But unfortunately, by epoch 100 our loss isn’t consistently decreasing: more training won’t make the result significantly better. Activations So far, we’ve only used the ReLU activation function. Taking a look at the output image, we see a lot of lines: various activations jump from zero to positive across these boundaries. There’s nothing fundamentally wrong with that—given a suitably large network, we could still represent the exact image. However, it’s difficult to recover high-frequency detail by summing functions clipped at zero. Sigmoids Because we know the network should always return values in \([0,1]\), one easy improvement is adding a sigmoid activation to the output layer. Instead of teaching the network to directly output an intensity in \([0,1]\), this will allow the network to compute values in \([-\infty,\infty]\) that are deterministically mapped to a color in \([0,1]\). We’ll apply the logistic function: \[\text{Sigmoid}(x) = \frac{1}{1 + e^{-x}}\] For all future experiments, we’ll use this function as an output layer activation. Re-training the ReLU network: Epochs: 100 The result looks significantly better, but it’s still got a lot of line-like artifacts. What if we just use the sigmoid activation for the other hidden layers, too? Re-training again… Epochs: 100 That made it worse. The important observation here is that changing the activation function can have a significant effect on reproduction quality. Several papers have been published comparing different activation functions in this context, so let’s try some of those. Sinusoids Implicit Neural Representations with Periodic Activation Functions This paper explores the usage of periodic functions (i.e. \(\sin,\cos\)) as activations, finding them well suited for representing signals like images, audio, video, and distance fields. In particular, the authors note that the derivative of a sinusoidal network is also a sinusoidal network. This observation allows them to fit differential constraints in situations where ReLU and TanH-based models entirely fail to converge. The proposed form of periodic activations is simply \(f(x) = \sin(\omega_0x)\), where \(\omega_0\) is a hyperparameter. Increasing \(\omega_0\) should allow the network to encode higher frequency signals. Let’s try changing our activations to \(f(x) = \sin(2\pi x)\): Epochs: 100 Well, that’s better than the ReLU/Sigmoid networks, but still not very impressive—an unstable training process lost much of the low frequency data. It turns out that sinusoidal networks are quite sensitive to how we initialize the weight matrices. To account for the extra scaling by \(\omega_0\), the paper proposes initializing weights beyond the first layer using the distribution \(\mathcal{U}(-\frac{1}{\omega_0}\sqrt{\frac{6}{\text{fan_in}}}, \frac{1}{\omega_0}\sqrt{\frac{6}{\text{fan_in}}})\). Retraining with proper weight initialization: Epochs: 100 Now we’re getting somewhere—the output is quite recognizable. However, we’re still missing a lot of high frequency detail, and increasing \(\omega_0\) much more starts to make training unstable. Gaussians Beyond Periodicity: Towards a Unifying Framework for Activations in Coordinate-MLPs This paper analyzes a variety of new activation functions, one of which is particularly suited for image reconstruction. It’s a gaussian of the form \(f(x) = e^{\frac{-x^2}{\sigma^2}}\), where \(\sigma\) is a hyperparameter. Here, a smaller \(\sigma\) corresponds to a higher bandwidth. The authors demonstrate good results using gaussian activations: reproduction as good as sinusoids, but without dependence on weight initialization or special input encodings (which we will discuss in the next section). So, let’s train our network using \(f(x) = e^{-4x^2}\): Epochs: 100 Well, that’s better than the initial sinusoidal network, but worse than the properly initialized one. However, something interesting happens if we scale up our input coordinates from \([-1,1]\) to \([-16,16]\): Epochs: 100 The center of the image is now reproduced almost perfectly, but the exterior still lacks detail. It seems that while gaussian activations are more robust to initialization, the distribution of inputs can still have a significant effect. Beyond the Training Set Although we’re only measuring how well each network reproduces the image, we might wonder what happens outside the training set. Luckily, our network is still just a function \(\mathbb{R}^2\mapsto\mathbb{R}^3\), so we can evaluate it on a larger range of inputs to produce an “out of bounds” image. Another purported benefit of using gaussian activations is sensible behavior outside of the training set, so let’s compare. Evaluating each network on \([-2,2]\times[-2,2]\): ReLU Sinusoid Gaussian That’s pretty cool—the gaussian network ends up representing a sort-of-edge-clamped extension of the image. The sinusoid turns into a low-frequency soup of common colors. The ReLU extension has little to do with the image content, and based on running training a few times, is very unstable. Input Encodings So far, our results are pretty cool, but not high fidelity enough to compete with the original image. Luckily, we can go further: recent research work on high-quality neural primitives has relied on not only better activation functions and training schemes, but new input encodings. When designing a network, an input encoding is essentially just a fixed-function initial layer that performs some interesting transformation before the fully-connected layers take over. It turns out that choosing a good initial transform can make a big difference. Positional Encoding The current go-to encoding is known as positional encoding, or otherwise positional embedding, or even sometimes fourier features. This encoding was first used in a graphics context by the original neural radiance fields paper. It takes the following form: \[x \mapsto \left[x, \sin(2^0\pi x), \cos(2^0\pi x), \dots, \sin(2^L\pi x), \cos(2^L\pi x) \right]\] Where \(L\) is a hyperparameter controlling bandwidth (higher \(L\), higher frequency signals). The unmodified input \(x\) may or may not be included in the output. When using this encoding, we transform our inputs by a hierarchy of sinusoids of increasing frequency. This brings to mind the fourier transform, hence the “fourier features” moniker, but note that we are not using the actual fourier transform of the training signal. So, let’s try adding a positional encoding to our network with \(L=6\). Our new network will have the following architecture: \[\mathbb{R}^2 \mapsto_{enc6} \mathbb{R}^{30} \mapsto_{fc} \mathbb{R}^{128} \mapsto_{fc} \mathbb{R}^{128} \mapsto_{fc} \mathbb{R}^{128} \mapsto_{fc} \mathbb{R}^3\] Note that the sinusoids are applied element-wise to our two-dimensional \(x\), so we end up with \(30\) input dimensions. This means the first fully-connected layer will have \(30\cdot128\) weights instead of \(2\cdot128\), so we are adding some parameters. However, the additional weights don’t make a huge difference in of themselves. The ReLU network improves dramatically: Epochs: 100 The gaussian network also improves significantly, now only lacking some high frequency detail: Epochs: 100 Finally, the sinusoidal network… fails to converge! Reducing \(\omega_0\) to \(\pi\) lets training succeed, and produces the best result so far. However, the unstable training behavior is another indication that sinusoidal networks are particularly temperamental. Epochs: 100 As a point of reference, saving this model’s parameters in half precision (which does not degrade quality) requires only 76kb on disk. That’s smaller than a JPEG encoding of the image at ~111kb, though not quite as accurate. Unfortunately, it’s still missing some fine detail. Instant Neural Graphics Primitives Instant Neural Graphics Primitives with a Multiresolution Hash Encoding This paper made a splash when it was released early this year and eventually won a best paper award at SIGGRAPH 2022. It proposes a novel input encoding based on a learned multi-resolution hashing scheme. By combining their encoding with a fully-fused (i.e. single-shader) training and evaluation implementation, the authors are able to train networks representing gigapixel-scale images, SDF geometry, volumes, and radiance fields in near real-time. In this post, we’re only interested in the encoding, though I wouldn’t say no to instant training either. The Multiresolution Grid We begin by breaking up the domain into several square grids of increasing resolution. This hierarchy can be defined in any number of dimensions \(d\). Here, our domain will be two-dimensional: Note that the green and red grids also tile the full image; their full extent is omitted for clarity. The resolution of each grid is a constant multiple of the previous level, but note that the growth factor does not have to be two. In fact, the authors derive the scale after choosing the following three hyperparameters: \[\begin{align*} L &amp;:= \text{Number of Levels} \\ N_{\min} &amp;:= \text{Coarsest Resolution} \\ N_{\max} &amp;:= \text{Finest Resolution} \end{align*}\] And compute the growth factor via: \[b := \exp\left(\frac{\ln N_{\max} - \ln N_{\min}}{L - 1}\right)\] Therefore, the resolution of grid level \(\ell\) is \(N_\ell := \lfloor N_\min b^\ell \rfloor\). Step 1 - Find Cells After choosing a hierarchy of grids, we can define the input transformation. We will assume the input \(\mathbf{x}\) is given in \([0,1]\). For each level \(\ell\), first scale \(\mathbf{x}\) by \(N_\ell\) and round up/down to find the cell containing \(\mathbf{x}\). For example, when \(N_\ell = 2\): Given the bounds of the cell containing \(\mathbf{x}\), we can then compute the integer coordinates of each corner of the cell. In this example, we end up with four vertices: \([0,0], [0,1], [1,0], [1,1]\). Step 2 - Hash Coordinates We then hash each corner coordinate. The authors use the following function: \[h(\mathbf{x}) = \bigoplus_{i=1}^d x_i\pi_i\] Where \(\oplus\) denotes bit-wise exclusive-or and \(\pi_i\) are large prime numbers. To improve cache coherence, the authors set \(\pi_1 = 1\), as well as \(\pi_2 = 2654435761\) and \(\pi_3 = 805459861\). Because our domain is two-dimensional, we only need the first two coefficients: \[h(x,y) = x \oplus (2654435761 y)\] The hash is then used as an index into a hash table. Each grid level has a corresponding hash table described by two more hyperparameters: \[\begin{align*} T &amp;:= \text{Hash Table Slots} \\ F &amp;:= \text{Features Per Slot} \end{align*}\] To map the hash to a slot in each level’s hash table, we simply modulo by \(T\). Each slot contains \(F\) learnable parameters. During training, we will backpropagate gradients all the way to the hash table entries, dynamically optimizing them to learn a good input encoding. What do we do about hash collisions? Nothing—the training process will automatically find an encoding that is robust to collisions. Unfortunately, this makes the encoding difficult to scale down to very small hash table sizes—eventually, simply too many grid points are assigned to each slot. Finally, the authors note that training is not particularly sensitive to how the hash table entries are initialized, but settle on an initial distribution \(\mathcal{U}(-0.0001,0.0001)\). Step 3 - Interpolate Once we’ve retrieved the \(2^d\) hash table slots corresponding to the current grid cell, we linearly interpolate their values to define a result at \(\mathbf{x}\) itself. In the two dimensional case, we use bi-linear interpolation: interpolate horizontally twice, then vertically once (or vice versa). The authors note that interpolating the discrete values is necessary for optimization with gradient descent: it makes the encoding function continuous. Step 4 - Concatenate At this point, we have mapped \(\mathbf{x}\) to \(L\) different vectors of length \(F\)—one for each grid level \(\ell\). To combine all of this information, we simply concatenate the vectors to form a single encoding of length \(LF\). The encoded result is then fed through a simple fully-connected neural network with ReLU activations (i.e. a multilayer perceptron). This network can be quite small: the authors use two hidden layers with dimension 64. Results Let’s implement the hash encoding and compare it with the earlier methods. The sinusoidal network with positional encoding might be hard to beat, given it uses only ~35k parameters. We will first choose \(L = 16\), \(N_\min = 16\), \(N_\max = 256\), \(T = 1024\), and \(F = 2\). Combined with a two hidden layer, dimension 64 MLP, these parameters define a model with 43,395 parameters. On disk, that’s about 90kb. Epochs: 30 That’s a good result, but not obviously better than we saw previously: when restricted to 1024-slot hash tables, the encoding can’t be perfect. However, the training process converges impressively quickly, producing a usable image after only three epochs and fully converging in 20-30. The sinusoidal network took over 80 epochs to converge, so fast convergence alone is a significant upside. The authors recommend a hash table size of \(2^{14}-2^{24}\): their use cases involve representing large volumetric data sets rather than 512x512 images. If we scale up our hash table to just 4096 entries (a parameter count of ~140k), the result at last becomes difficult to distinguish from the original image. The other techniques would have required even more parameters to achieve this level of quality. Epochs: 30 The larger hash maps result in a ~280kb model on disk, which, while much smaller than the uncompressed image, is over twice as large as an equivalent JPEG. The hash encoding really shines when representing much higher resolution images: at gigapixel scale it handily beats the other methods in reproduction quality, training time, and model size. (These results were compared against the reference implementation using the same parameters—the outputs were equivalent, except for my version being many times slower!) More Applications So far, we’ve only explored ways to represent images. But, as mentioned at the start, neural models can encode any dataset we can express as a function. In fact, current research work primarily focuses on representing geometry and light fields—images are the easy case. Neural SDFs One relevant way to represent surfaces is using signed distance functions, or SDFs. At every point \(\mathbf{x}\), an SDF \(f\) computes the distance between \(\mathbf{x}\) and the closest point on the surface. When \(\mathbf{x}\) is inside the surface, \(f\) instead returns the negative distance. Hence, the surface is defined as the set of points such that \(f(\mathbf{x}) = 0\), also known as the zero level set of \(f\). SDFs can be very simple to define and combine, and when combined with sphere tracing, can create remarkable results in a few lines of code. Hugh Kennedy Because SDFs are simply functions from position to distance, they’re easy to represent with neural models: all of the techniques we explored for images also apply when representing distance fields. Traditionally, graphics research and commercial tools have favored explicit geometric representations like triangle meshes—and broadly still do—but the advent of ML models is bringing implicit representations like SDFs back into the spotlight. Luckily, SDFs can be converted into meshes using methods like marching cubes and dual contouring, though this introduces discretization error. Implicit Neural Representations with Periodic Activation Functions When working with neural representations, one may not even require proper distances—it may be sufficient that \(f(\mathbf{x}) = 0\) describes the surface. Techniques in this broader class are known as level set methods. Another SIGGRAPH 2022 best paper, Spelunking the Deep, defines relatively efficient closest point, collision, and ray intersection queries on arbitrary neural surfaces. Neural Radiance Fields In computer vision, another popular use case is modelling light fields. A light field can be encoded in many ways, but the model proposed in the original NeRF paper maps a 3D position and 2D angular direction to RGB radiance and volumetric density. This function provides enough information to synthesize images of the field using volumetric ray marching. (Basically, trace a ray in small steps, adding in radiance and attenuating based on density.) \[x, y, z, \theta, \phi \mapsto R, G, B, \sigma\] Because NeRFs are trained to match position and direction to radiance, one particularly successful use case has been using a set of 2D photographs to learn a 3D representation of a scene. Though NeRFs are not especially conducive to recovering geometry and materials, synthesizing images from entirely new angles is relatively easy—the model defines the full light field. NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis There has been an explosion of NeRF-related papers over the last two years, many of which choose different parameterizations of the light field. Some even ditch the neural encoding entirely. Using neural models to represent light fields also helped kickstart research on the more general topic of differentiable rendering, which seeks to separately recover scene parameters like geometry, materials, and lighting by reversing the rendering process via gradient descent. Neural Radiance Cache In real-time rendering, another exciting application is neural radiance caching. NRC brings NeRF concepts into the real-time ray-tracing world: a model is trained to encode a radiance field at runtime, dynamically learning from small batches of samples generated every frame. The resulting network is used as an intelligent cache to estimate incoming radiance for secondary rays—without recursive path tracing. Real-time Neural Radiance Caching for Path Tracing References This website attempts to collate all recent literature on neural fields: Neural Fields in Visual Computing and Beyond Papers referenced in this article: Implicit Neural Representations with Periodic Activation Functions Beyond Periodicity: Towards a Unifying Framework for Activations in Coordinate-MLPs NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis Instant Neural Graphics Primitives with a Multiresolution Hash Encoding Spelunking the Deep: Guaranteed Queries on General Neural Implicit Surfaces via Range Analysis PlenOctrees For Real-time Rendering of Neural Radiance Fields Real-time Neural Radiance Caching for Path Tracing More particularly cool papers: Neural Geometric Level of Detail: Real-time Rendering with Implicit 3D Shapes Learning Smooth Neural Functions via Lipschitz Regularization A Level Set Theory for Neural Implicit Evolution under Explicit Flows Implicit Neural Spatial Representations for Time-dependent PDEs Intrinsic Neural Fields: Learning Functions on Manifolds]]></summary>
        <author>
            <name>Max Slater</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[NYC II]]></title>
        <id>https://thenumbat.github.io/NYC-II/</id>
        <link href="https://thenumbat.github.io/NYC-II/"/>
        <updated>2022-11-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[New York, NY, 2022]]></summary>
        <author>
            <name>Max Slater</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Pure C] Clang is better than GCC]]></title>
        <id>https://yurichev.org/clang/</id>
        <link href="https://yurichev.org/clang/"/>
        <updated>2022-11-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[[Pure C] Clang is better than GCC]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Version 1.6.10 released]]></title>
        <id>/blog/2022/11/23/version-1610-released.html</id>
        <link href="https://nim-lang.org/blog/2022/11/23/version-1610-released.html"/>
        <updated>2022-11-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The Nim team is happy to announce version 1.6.10, our fifth patch release for
Nim 1.6.
Version 1.6.10 is a result of almost four months of hard work, and it contains
29 commits,
bringing some general improvements over 1.6.8.
This version brings OpenSSL 3 support
to Nim 1.6, and large allocations and deallocations for ARC/ORC are now
faster.
We would recommend to all of our users to upgrade and use version 1.6.10.
Installing Nim 1.6
New users
Check out if the package manager of your OS already ships version 1.6.10 or
install it as described here.
Existing users
If you have installed a previous version of Nim using choosenim,
getting Nim 1.6.10 is as easy as:
$ choosenim update stable

Alternatively, you can download Nim 1.6.10 from
our nightlies builds.
Donating to Nim
We would like to encourage you to donate to Nim.
The donated money will be used to further improve Nim by creating bounties
for the most important bugfixes and features.
You can donate via:
Open Collective
Patreon
BountySource
PayPal
Bitcoin: 1BXfuKM2uvoD6mbx4g5xM3eQhLzkCK77tJ
If you are a company, we also offer commercial support.
Bugfixes
These reported issues were fixed:
Fixed “–styleCheck:off does not work (and –styleCheck:hint is now the default?)”
(#20397)
Fixed “dereferencing pointer to incomplete type error with gcc 9.4 with statics/cast”
(#20141)
Fixed “strutils.find uses cstring optimization that stops after \0”
(#19500)
Fixed “Nimpretty mangles numeric literal procs”
(#20553)
Fixed “Regression in proc symbol resolution; Error: attempting to call routine “
(#18990)
Fixed “of operator doesn’t consider generics under orc/arc”
(#20391)
Fixed ““incompatible type” when mixing float32 and cfloat in generics”
(#19349)
Fixed “cannot generate code for: mSlice with toOpenArray”
(#19969)
Fixed “-mm flag is ignored on latest Nim 1.7.1 be4bd8”
(#20426)
The complete list of changes is available
here.]]></summary>
        <author>
            <name>Nim Programming Language</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Python] Wordclouds for your book library]]></title>
        <id>https://yurichev.org/wordcloud/</id>
        <link href="https://yurichev.org/wordcloud/"/>
        <updated>2022-11-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[[Python] Wordclouds for your book library]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[For your eyes only: improving Netflix video quality with neural networks]]></title>
        <id>https://medium.com/p/5b8d032da09c</id>
        <link href="https://netflixtechblog.com/for-your-eyes-only-improving-netflix-video-quality-with-neural-networks-5b8d032da09c?source=rss----2615bd06b42e---4"/>
        <updated>2022-11-17T21:08:00.000Z</updated>
        <summary type="html"><![CDATA[by Christos G. Bampis, Li-Heng Chen and Zhi Li]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Match Cutting at Netflix: Finding Cuts with Smooth Visual Transitions]]></title>
        <id>https://medium.com/p/31c3fc14ae59</id>
        <link href="https://netflixtechblog.com/match-cutting-at-netflix-finding-cuts-with-smooth-visual-transitions-31c3fc14ae59?source=rss----2615bd06b42e---4"/>
        <updated>2022-11-17T16:37:01.000Z</updated>
        <summary type="html"><![CDATA[What’s needed in the art of match cutting is tools to help editors find shots that match well together, which is what we’ve started…]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[NYC I]]></title>
        <id>https://thenumbat.github.io/NYC-I/</id>
        <link href="https://thenumbat.github.io/NYC-I/"/>
        <updated>2022-11-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[New York, NY, 2022]]></summary>
        <author>
            <name>Max Slater</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cut for time]]></title>
        <id>https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-8</id>
        <link href="https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-8"/>
        <updated>2022-11-15T19:30:08.000Z</updated>
        <summary type="html"><![CDATA[<p>This series has to end <em>somewhere</em>, so let's end it here!</p>
<p>However, here is a list of some things I'd like to come back to:</p>

                        <h2>
                            <a id="bundling-typescript" class="anchor" href="#bundling-typescript">
                                Bundling & TypeScript
                            </a>
                        </h2>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Async fn in trait, for real this time]]></title>
        <id>https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-7</id>
        <link href="https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-7"/>
        <updated>2022-11-15T19:30:07.000Z</updated>
        <summary type="html"><![CDATA[<h2>
                            <a id="async-trait-s-one-weird-type-ascription-trick" class="anchor" href="#async-trait-s-one-weird-type-ascription-trick">
                                <code>async_trait</code>'s one weird type ascription trick
                            </a>
                        </h2>
                        
<p>Now that I got <a href="part-6">the Log in with GitHub feature</a> working, let's explore
what this would've looked like with the <code>async_trait</code> crate.</p>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Implementing "Log in with GitHub"]]></title>
        <id>https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-6</id>
        <link href="https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-6"/>
        <updated>2022-11-15T19:30:06.000Z</updated>
        <summary type="html"><![CDATA[<p>Because I started accepting donations via <a href="/donate">GitHub Sponsors</a>, and
because donating at the &quot;Silver&quot; tier or above gives you advance access to
articles <em>and</em> your name in the credits, I need to interface with the GitHub
API the same way I do the Patreon API.</p>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Trying to use nix]]></title>
        <id>https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-5</id>
        <link href="https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-5"/>
        <updated>2022-11-15T19:30:05.000Z</updated>
        <summary type="html"><![CDATA[<p>Now that my website is <a href="part-4">deployed as a container image</a>, I wanted to give 
<a href="https://nixos.org/">nix</a> a try. I'm still doing it the old-fashioned way right
now: with a <code>Dockerfile</code>, running <code>cargo</code> in a &quot;builder&quot; image, copying stuff
out of there into a slimmer image (that still has an Ubuntu base, even though
<a href="https://github.com/GoogleContainerTools/distroless">distroless images</a> are a
thing now).</p>

                        <h2>
                            <a id="but-why" class="anchor" href="#but-why">
                                But why?
                            </a>
                        </h2>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deploying at the edge]]></title>
        <id>https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-4</id>
        <link href="https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-4"/>
        <updated>2022-11-15T19:30:04.000Z</updated>
        <summary type="html"><![CDATA[<div class="disclosure">
	<strong>Disclosure</strong>: 
Although I no longer work for the company my website is hosted on, and this
article is written in way that mentions neither my previous or current hosting
provider: at the time of this writing, I don't pay for hosting.
</div>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Async fn in trait... not]]></title>
        <id>https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-3</id>
        <link href="https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-3"/>
        <updated>2022-11-15T19:30:03.000Z</updated>
        <summary type="html"><![CDATA[<h2>
                            <a id="async-fn-in-trait-not" class="anchor" href="#async-fn-in-trait-not">
                                Async fn in trait... not
                            </a>
                        </h2>
                        
<p>I was planning on showing the in-progress <code>async_fn_in_trait</code> feature in the
context of my website, but it turns out, I can't!</p>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Migrating from warp to axum]]></title>
        <id>https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-2</id>
        <link href="https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-2"/>
        <updated>2022-11-15T19:30:02.000Z</updated>
        <summary type="html"><![CDATA[<h2>
                            <a id="falling-out-of-love-with-warp" class="anchor" href="#falling-out-of-love-with-warp">
                                Falling out of love with <code>warp</code>
                            </a>
                        </h2>
                        
<p>Back when I wrote this codebase, <a href="https://lib.rs/crates/warp">warp</a> was the best
/ only alternative for something relatively high-level on top of
<a href="https://lib.rs/crates/hyper">hyper</a>.</p>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cleaning up and upgrading third-party crates]]></title>
        <id>https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-1</id>
        <link href="https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-1"/>
        <updated>2022-11-15T19:30:01.000Z</updated>
        <summary type="html"><![CDATA[<h2>
                            <a id="the-bleeding-edge-of-rustc-and-clippy" class="anchor" href="#the-bleeding-edge-of-rustc-and-clippy">
                                The bleeding edge of rustc and clippy
                            </a>
                        </h2>
                        
<p>Typically, you'd want a production application to use a stable version of Rust.
At the time of this writing, that's Rust 1.65.0, which stabilizes a bunch of
long-awaited features (GATs, let-else, MIR inlining, split debug info, etc.).</p>
<div class="tip">
<div class="tip-header">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M21.41 41.398c.148-1.787.337-3.572.574-5.351.369-2.772 4.393-11.308 5.624-12.882l.553-.706-1.344-.449a5.772 5.772 0 0 1-3.948-5.478 5.786 5.786 0 0 1 5.779-5.78 5.768 5.768 0 0 1 5.684 4.758l.249 1.396 1.231-.704a28.845 28.845 0 0 1 14.282-3.801c4.991 0 9.93 1.314 14.282 3.801l1.231.704.249-1.396a5.766 5.766 0 0 1 5.683-4.758 5.786 5.786 0 0 1 5.779 5.78 5.772 5.772 0 0 1-3.948 5.478l-1.344.449.552.705c1.911 2.44 2.55 2.541 3.563 5.599 1.422 4.293 2.923 7.964 2.923 12.61v49.875h2V41.373c0-6.519-2.008-12.717-5.819-18.005a7.768 7.768 0 0 0 4.072-6.836c0-4.29-3.49-7.78-7.779-7.78a7.766 7.766 0 0 0-7.3 5.1 30.834 30.834 0 0 0-14.146-3.45 30.834 30.834 0 0 0-14.146 3.45 7.766 7.766 0 0 0-7.301-5.1c-4.289 0-7.779 3.49-7.779 7.78a7.766 7.766 0 0 0 4.072 6.836c-6.681 9.271-5.976 21.037-5.992 32.034-.017 11.946.656 23.895.109 35.838l2.006-.001c.67 0-.17-33.831-.156-36.912.022-4.312.148-8.631.505-12.929z"/><path d="M73.854 31.271v-4.494c0-.971-.79-1.76-1.761-1.76H55.235c-.604 0-1.3.869-1.778 1.905-.015 0-.027-.008-.042-.008H46.789c-.02 0-.037.011-.057.011-.478-1.037-1.175-1.908-1.779-1.908H28.094c-.971 0-1.761.79-1.761 1.76v4.494c0 4.477 3.643 8.119 8.119 8.119h5.12c4.265 0 7.734-3.47 7.734-7.734v-2.091H52.878v2.091c0 4.265 3.47 7.734 7.734 7.734h5.121c4.479-.001 8.121-3.643 8.121-8.119zm-41.713 3.192a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm11.163-2.18l-5.75 3.597a.95.95 0 0 1-1.313-.302.952.952 0 0 1 .303-1.312l5.75-3.597a.953.953 0 0 1 1.01 1.614zm15.168 1.935a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm4.909 1.561a.953.953 0 0 1-.506-1.759l5.75-3.597a.952.952 0 1 1 1.01 1.614l-5.75 3.597a.942.942 0 0 1-.504.145z"/><path d="M59.705 45.232h-2c0 1.823-1.483 3.306-3.306 3.306s-3.306-1.483-3.306-3.306v-1.439h1.06a3.294 3.294 0 0 0 3.285-3.285v-.17c0-.259-.038-.508-.095-.749a3.291 3.291 0 0 0-2.665-2.482 3.243 3.243 0 0 0-.525-.053h-4.12c-.18 0-.353.025-.525.053a3.291 3.291 0 0 0-2.665 2.482 3.255 3.255 0 0 0-.095.749v.17a3.294 3.294 0 0 0 3.285 3.285h1.06v1.439a3.31 3.31 0 0 1-3.307 3.306 3.31 3.31 0 0 1-3.306-3.306h-2a5.312 5.312 0 0 0 5.306 5.306 5.293 5.293 0 0 0 4.306-2.229 5.294 5.294 0 0 0 4.306 2.229 5.313 5.313 0 0 0 5.307-5.306zM29.742 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM43.779 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM57.816 58.336a.703.703 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM71.853 58.336a.704.704 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM35.354 71.559v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-1.406 0zM49.39 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM63.427 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM29.038 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-.703-.703zM43.076 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.705.705 0 0 0-.703-.703zM57.113 81.364a.704.704 0 0 0-.704.703v5.369a.704.704 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.703-.703zM71.149 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.704-.703z"/></svg>
Cool bear's hot tip
</div>

</div>]]></summary>
        <author>
            <name>fasterthanli.me</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Helping VFX studios pave a path to the cloud]]></title>
        <id>https://medium.com/p/d308ee43c079</id>
        <link href="https://netflixtechblog.com/helping-vfx-studios-pave-a-path-to-the-cloud-d308ee43c079?source=rss----2615bd06b42e---4"/>
        <updated>2022-11-15T17:03:55.000Z</updated>
        <summary type="html"><![CDATA[By: Peter Cioni (Netflix), Alex Schworer (Netflix), Mac Moore (Conductor Tech.), Rachel Kelley (AWS), Ranjit Raju (AWS)]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Unix] Logging your work using suckless dwm]]></title>
        <id>https://yurichev.org/dwm/</id>
        <link href="https://yurichev.org/dwm/"/>
        <updated>2022-11-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[[Unix] Logging your work using suckless dwm]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Math][RevEng] Boolean algebra for noobs: stack alignment]]></title>
        <id>https://yurichev.org/bool2/</id>
        <link href="https://yurichev.org/bool2/"/>
        <updated>2022-11-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[[Math][RevEng] Boolean algebra for noobs: stack alignment]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Yet another self-referential joke about loser]]></title>
        <id>https://yurichev.org/selfref/</id>
        <link href="https://yurichev.org/selfref/"/>
        <updated>2022-11-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Yet another self-referential joke about loser]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[New Series: Creating Media with Machine Learning]]></title>
        <id>https://medium.com/p/5067ac110bcd</id>
        <link href="https://netflixtechblog.com/new-series-creating-media-with-machine-learning-5067ac110bcd?source=rss----2615bd06b42e---4"/>
        <updated>2022-11-11T17:26:39.000Z</updated>
        <summary type="html"><![CDATA[This blog series will be showing you how we use the power of machine learning to create stunning media at a global scale.]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Machine Learning for Fraud Detection in Streaming Services]]></title>
        <id>https://medium.com/p/b0b4ef3be3f6</id>
        <link href="https://netflixtechblog.com/machine-learning-for-fraud-detection-in-streaming-services-b0b4ef3be3f6?source=rss----2615bd06b42e---4"/>
        <updated>2022-11-11T17:26:15.000Z</updated>
        <summary type="html"><![CDATA[By Soheil Esmaeilzadeh, Negin Salajegheh, Amir Ziai, Jeff Boote]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[A cost model for Nim]]></title>
        <id>/blog/2022/11/11/a-cost-model-for-nim.html</id>
        <link href="https://nim-lang.org/blog/2022/11/11/a-cost-model-for-nim.html"/>
        <updated>2022-11-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A cost model for Nim
It is impossible to design a system so perfect that no one needs to be
good.
— T. S. Eliot
This blog post is the beginning of a cost model for the implementation
that is available via “Nim devel” aka Nim version 2.
This implementation was designed for embedded, hard real-time
systems. Generally speaking, assuming you have enough RAM (which is
about 64 kB) all of Nim’s language features are supported –
including exception handling and heap-based storage. The implementation
of these features also works on bare metal, without an operating system.
Heap-based storage
Why the focus on embedded, hard real-time systems? Because when you do
these well you can also do everything else well! The algorithms used are
oblivious to the heap size: Nim’s memory management works well wit…]]></summary>
        <author>
            <name>Nim Programming Language</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Seeing through hardware counters: a journey to threefold performance increase]]></title>
        <id>https://medium.com/p/2721924a2822</id>
        <link href="https://netflixtechblog.com/seeing-through-hardware-counters-a-journey-to-threefold-performance-increase-2721924a2822?source=rss----2615bd06b42e---4"/>
        <updated>2022-11-09T23:47:03.000Z</updated>
        <summary type="html"><![CDATA[By Vadim Filanovsky and Harshad Sane]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Math] Boolean algebra for noobs: easy exercise]]></title>
        <id>https://yurichev.org/bool/</id>
        <link href="https://yurichev.org/bool/"/>
        <updated>2022-11-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[[Math] Boolean algebra for noobs: easy exercise]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Learn reverse engineering: but where to start?]]></title>
        <id>https://yurichev.org/RE_start/</id>
        <link href="https://yurichev.org/RE_start/"/>
        <updated>2022-11-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn reverse engineering: but where to start?]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[CPU vs (GP)GPU: the difference]]></title>
        <id>https://yurichev.org/GPU/</id>
        <link href="https://yurichev.org/GPU/"/>
        <updated>2022-11-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[CPU vs (GP)GPU: the difference]]></summary>
        <author>
            <name>Dennis Yurichev's blog</name>
        </author>
    </entry>
</feed>