<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>urn:2023-09-17T00:53:54.972Z</id>
    <title>osmos::feed</title>
    <updated>2023-09-17T00:53:54.973Z</updated>
    <generator>osmosfeed 1.15.1</generator>
    <link rel="alternate" href="index.html"/>
    <entry>
        <title type="html"><![CDATA[Transcoding Unicode strings at crazy speeds with AVX-512]]></title>
        <id>https://lemire.me/blog/?p=20820</id>
        <link href="https://lemire.me/blog/2023/09/13/transcoding-unicode-strings-at-crazy-speeds-with-avx-512/"/>
        <updated>2023-09-13T16:00:30.000Z</updated>
        <summary type="html"><![CDATA[In software, we store strings of text as arrays of bytes in memory using one of the Unicode Transformation Formats (UTF), the most popular being UTF-8 and UTF-16. Windows, Java, C# and other systems common languages and systems default on UTF-16, whereas other systems and most of the web relies on UTF-8. There are benefits … Continue reading Transcoding Unicode strings at crazy speeds with AVX-512]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Comparative Analysis]]></title>
        <id>https://matklad.github.io/2023/09/13/comparative-analysis.html</id>
        <link href="https://matklad.github.io/2023/09/13/comparative-analysis.html"/>
        <updated>2023-09-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Most languages provide 6 comparison operators:]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Locating ‘identifiers’ quickly (ARM NEON edition)]]></title>
        <id>https://lemire.me/blog/?p=20798</id>
        <link href="https://lemire.me/blog/2023/09/04/locating-identifiers-quickly-arm-neon-edition/"/>
        <updated>2023-09-04T00:46:18.000Z</updated>
        <summary type="html"><![CDATA[A common problem in parsing is that you want to find all identifiers (e.g., variable names, function names) in a document quickly. There are typically some fixed rules. For example, it is common to allow ASCII letters and digits as well as characters like ‘_’ in the identifier, but to forbid some characters at the … Continue reading Locating ‘identifiers’ quickly (ARM NEON edition)]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Science and Technology links (September 2 2023)]]></title>
        <id>https://lemire.me/blog/?p=20790</id>
        <link href="https://lemire.me/blog/2023/09/02/science-and-technology-links-september-2-2023/"/>
        <updated>2023-09-02T18:30:10.000Z</updated>
        <summary type="html"><![CDATA[Physicists have a published a paper with 5154 authors. The list of authors takes 24 pages out of the 33 pages. The lesson is that if someone tell you that they have published an important paper, you should ask how many authors there were and what their exact role was. Vegatarians are at higher risk … Continue reading Science and Technology links (September 2 2023)]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[This Month with Nim: July and August 2023]]></title>
        <id>https://nim-lang.org//blog/2023/09/01/this-month-with-nim.html</id>
        <link href="https://nim-lang.org//blog/2023/09/01/this-month-with-nim.html"/>
        <updated>2023-09-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[HappyX
Author: ethosa
HappyX is a macro-oriented full-stack web framework that combines frontend and backend features.
With HappyX you can write single page applications (SPA),
static site generation (SSG),
and server side rendering (SSR) web applications.
It provides the same syntax for all of these solutions:
import happyx

serve("127.0.0.1", 5000):
  "/":
    "Hello, world!"

or:
import happyx

appRoutes("app"):
  "/":
    "Hello, world!"

Included is a command line interface hpx.
This enables easy creation of projects for Nim and Python.
A non exhaustive list of features is as follows:
Multiple server options (built-in asynchttpserver, microasynchttpserver, httpbeast and httpx)
Hot code reloading (now only for SPA)
Debug logging with -d:debug
Powerful routing that includes path params …]]></summary>
        <author>
            <name>Nim Programming Language</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zero Configuration Service Mesh with On-Demand Cluster Discovery]]></title>
        <id>https://medium.com/p/ac6483b52a51</id>
        <link href="https://netflixtechblog.com/zero-configuration-service-mesh-with-on-demand-cluster-discovery-ac6483b52a51?source=rss----2615bd06b42e---4"/>
        <updated>2023-08-29T23:08:45.000Z</updated>
        <summary type="html"><![CDATA[Netflix’s service mesh adoption: history, motivations, and how we worked with the Envoy community on a feature to streamline mesh adoption]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to link identical function names from different DLLs]]></title>
        <id>https://nullprogram.com/blog/2023/08/27/</id>
        <link href="https://nullprogram.com/blog/2023/08/27/"/>
        <updated>2023-08-27T01:46:31.000Z</updated>
        <summary type="html"><![CDATA[For the typical DLL function call you declare the function prototype (via
header file), you inform the link editor (ld, link) that the DLL
exports a symbol with that name (import library), it matches the declared
name with this export, and it becomes an import in your program’s import
table. What happens when two different DLLs export the same symbol? The
link editor will pick the first found. But what if you want to use both
exports? If they have the same name, how could program or link editor
distinguish them? In this article I’ll demonstrate a technique to resolve
this by creating a program which links with and directly uses two
different C runtimes (CRTs) simultaneously.
In PE executable images, an import isn’t just a symbol, but a tuple
of DLL name and symbol. For human display, a tup…]]></summary>
        <author>
            <name>null program</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Everything you never wanted to know about Win32 environment blocks]]></title>
        <id>https://nullprogram.com/blog/2023/08/23/</id>
        <link href="https://nullprogram.com/blog/2023/08/23/"/>
        <updated>2023-08-23T21:51:10.000Z</updated>
        <summary type="html"><![CDATA[In an effort to avoid programming by superstition, I did a deep dive
into the Win32 “environment block,” the data structure holding a process’s
environment variables, in order to better understand it. Along the way I
discovered implied and undocumented behaviors. (The environment block
must not to be confused with the Process Environment Block (PEB)
which is different.) Because I cannot possibly retain all the quirky
details in my head for long, I’m writing them down for future reference. I
ran my tests on different Windows versions as far back as Windows XP SP3
in order to fill in gaps where documentation is ambiguous, incomplete, or
wrong. Overall conclusion: Correct, direct manipulation of an environment
block is impossible in the general case due to under-specified and
incorrect docume…]]></summary>
        <author>
            <name>null program</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Transcoding Latin 1 strings to UTF-8 strings at 18 GB/s using AVX-512]]></title>
        <id>https://lemire.me/blog/?p=20758</id>
        <link href="https://lemire.me/blog/2023/08/18/transcoding-latin-1-strings-to-utf-8-strings-at-12-gb-s-using-avx-512/"/>
        <updated>2023-08-18T18:17:42.000Z</updated>
        <summary type="html"><![CDATA[Though most strings online today follow the Unicode standard (e.g., using UTF-8), the Latin 1 standard is still in widespread inside some systems (such as browsers) as JavaScript strings are often stored as either Latin 1, UTF-8 or UTF-16 internally. Latin 1 captures the first 256 characters from the Unicode standard and represents them as … Continue reading Transcoding Latin 1 strings to UTF-8 strings at 18 GB/s using AVX-512]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
</feed>