<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>urn:2023-08-27T00:52:48.097Z</id>
    <title>osmos::feed</title>
    <updated>2023-08-27T00:52:48.097Z</updated>
    <generator>osmosfeed 1.15.1</generator>
    <link rel="alternate" href="index.html"/>
    <entry>
        <title type="html"><![CDATA[Everything you never wanted to know about Win32 environment blocks]]></title>
        <id>https://nullprogram.com/blog/2023/08/23/</id>
        <link href="https://nullprogram.com/blog/2023/08/23/"/>
        <updated>2023-08-23T21:51:10.000Z</updated>
        <summary type="html"><![CDATA[In an effort to avoid programming by superstition, I did a deep dive
into the Win32 “environment block,” the data structure holding a process’s
environment variables, in order to better understand it. Along the way I
discovered implied and undocumented behaviors. (The environment block
must not to be confused with the Process Environment Block (PEB)
which is different.) Because I cannot possibly retain all the quirky
details in my head for long, I’m writing them down for future reference. I
ran my tests on different Windows versions as far back as Windows XP SP3
in order to fill in gaps where documentation is ambiguous, incomplete, or
wrong. Overall conclusion: Correct, direct manipulation of an environment
block is impossible in the general case due to under-specified and
incorrect docume…]]></summary>
        <author>
            <name>null program</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Transcoding Latin 1 strings to UTF-8 strings at 18 GB/s using AVX-512]]></title>
        <id>https://lemire.me/blog/?p=20758</id>
        <link href="https://lemire.me/blog/2023/08/18/transcoding-latin-1-strings-to-utf-8-strings-at-12-gb-s-using-avx-512/"/>
        <updated>2023-08-18T18:17:42.000Z</updated>
        <summary type="html"><![CDATA[Though most strings online today follow the Unicode standard (e.g., using UTF-8), the Latin 1 standard is still in widespread inside some systems (such as browsers) as JavaScript strings are often stored as either Latin 1, UTF-8 or UTF-16 internally. Latin 1 captures the first 256 characters from the Unicode standard and represents them as … Continue reading Transcoding Latin 1 strings to UTF-8 strings at 18 GB/s using AVX-512]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[AVA Discovery View: Surfacing Authentic Moments]]></title>
        <id>https://medium.com/p/b8cd145491cc</id>
        <link href="https://netflixtechblog.com/ava-discovery-view-surfacing-authentic-moments-b8cd145491cc?source=rss----2615bd06b42e---4"/>
        <updated>2023-08-17T22:07:14.000Z</updated>
        <summary type="html"><![CDATA[By: Hamid Shahid, Laura Johnson, Tiffany Low]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript is Surprisingly OK for Compilers]]></title>
        <id>https://matklad.github.io/2023/08/17/typescript-is-surprisingly-ok-for-compilers.html</id>
        <link href="https://matklad.github.io/2023/08/17/typescript-is-surprisingly-ok-for-compilers.html"/>
        <updated>2023-08-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[There are two main historical trends when choosing an implementation language for something
compiler-shaped.]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Curbing Connection Churn in Zuul]]></title>
        <id>https://medium.com/p/2feb273a3598</id>
        <link href="https://netflixtechblog.com/curbing-connection-churn-in-zuul-2feb273a3598?source=rss----2615bd06b42e---4"/>
        <updated>2023-08-16T17:55:48.000Z</updated>
        <summary type="html"><![CDATA[Netflix’s Zuul Gateway eliminated tens of millions of connections and reduced almost all connection churn to backends]]></summary>
        <author>
            <name>Netflix Technology Blog</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How accurate is the birthday’s paradox formula?]]></title>
        <id>https://lemire.me/blog/?p=20745</id>
        <link href="https://lemire.me/blog/2023/08/15/how-accurate-is-the-birthdays-paradox-formula/"/>
        <updated>2023-08-15T17:28:53.000Z</updated>
        <summary type="html"><![CDATA[Given a set of r random values from a large set (of size N), I have been using the formula 1-exp(-r**2/(2N)) to approximate the probability of a collision. It assumes that r is much smaller than N. The formula suggests that if you have hundreds of millions of random 64-bit numbers, you will start getting … Continue reading How accurate is the birthday’s paradox formula?]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[NYC: Botanical Garden]]></title>
        <id>https://thenumb.at/NYBG/</id>
        <link href="https://thenumb.at/NYBG/"/>
        <updated>2023-08-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[New York Botanical Garden, New York, NY, 2023]]></summary>
        <author>
            <name>Max Slater</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Role Of Algorithms]]></title>
        <id>https://matklad.github.io/2023/08/13/role-of-algorithms.html</id>
        <link href="https://matklad.github.io/2023/08/13/role-of-algorithms.html"/>
        <updated>2023-08-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is lobste.rs comment as an article, so expect even more abysmal editing than usual.]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Transcoding UTF-8 strings to Latin 1 strings at 18 GB/s using AVX-512]]></title>
        <id>https://lemire.me/blog/?p=20738</id>
        <link href="https://lemire.me/blog/2023/08/12/transcoding-utf-8-strings-to-latin-1-strings-at-12-gb-s-using-avx-512/"/>
        <updated>2023-08-12T01:18:50.000Z</updated>
        <summary type="html"><![CDATA[Most strings online are Unicode strings in the UTF-8 format. Other systems (e.g., Java, Microsoft) might prefer UTF-16. However, Latin 1 is still a common encoding (e.g., within JavaScript runtimes). Its relationship with Unicode is simple: Latin 1 includes the first 256 Unicode characters. It is rich enough to convert most of the standard European … Continue reading Transcoding UTF-8 strings to Latin 1 strings at 18 GB/s using AVX-512]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Coding of domain names to wire format at gigabytes per second]]></title>
        <id>https://lemire.me/blog/?p=20735</id>
        <link href="https://lemire.me/blog/2023/08/10/coding-of-domain-names-to-wire-format-at-gigabytes-per-second/"/>
        <updated>2023-08-10T02:02:57.000Z</updated>
        <summary type="html"><![CDATA[When you enter in your browser the domain name lemire.me, it eventually gets encoded into a so-called wire format. The name lemire.me contains two labels, one of length 6 (lemire) and one of length two (me). The wire format starts with 6lemire2me: that is, imagining that the name starts with an imaginary dot, all dots … Continue reading Coding of domain names to wire format at gigabytes per second]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Types and the Zig Programming Language]]></title>
        <id>https://matklad.github.io/2023/08/09/types-and-zig.html</id>
        <link href="https://matklad.github.io/2023/08/09/types-and-zig.html"/>
        <updated>2023-08-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Notes on less-than-obvious aspects of Zig's type system and things that surprised me after diving
deeper into the language.]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Science and Technology links (August 6 2023)]]></title>
        <id>https://lemire.me/blog/?p=20728</id>
        <link href="https://lemire.me/blog/2023/08/06/science-and-technology-links-august-6-2023/"/>
        <updated>2023-08-06T20:43:06.000Z</updated>
        <summary type="html"><![CDATA[In an extensive study, You et al. (2022) found that meat consumption was correlated with higher life expectancies: Meat intake is positively correlated with life expectancies. This relationship remained significant when influences of caloric intake, urbanization, obesity, education and carbohydrate crops were statistically controlled. Stepwise linear regression selected meat intake, not carbohydrate crops, as one … Continue reading Science and Technology links (August 6 2023)]]></summary>
        <author>
            <name>Daniel Lemire</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fantastic Learning Resources]]></title>
        <id>https://matklad.github.io/2023/08/06/fantastic-learning-resources.html</id>
        <link href="https://matklad.github.io/2023/08/06/fantastic-learning-resources.html"/>
        <updated>2023-08-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[People sometimes ask me: Alex, how do I learn X?. This article is a compilation of advice I
usually give. This is things that worked for me rather than the most awesome things on earth. I
do consider every item on the list to be fantastic though, and I am forever grateful to people
putting these resources together.]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nim v2.0 released]]></title>
        <id>https://nim-lang.org//blog/2023/08/01/nim-v20-released.html</id>
        <link href="https://nim-lang.org//blog/2023/08/01/nim-v20-released.html"/>
        <updated>2023-08-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The Nim team is proud and happy to announce Nim version 2.0.
This is an evolution (not revolution) of Nim, bringing ORC memory management as a default, along with many other new features and improvements.
Nim is a programming language that is good for everything, but not for everybody.
It focuses on the imperative programming paradigm and enhances it with a macro system.
Its customizable memory management makes it well suited for unforgiving domains such as hard realtime systems and system programming in general.
Installing Nim 2.0
New users
Check out if the package manager of your OS already ships version 2.0 or
install it as described here.
Existing users
If you have installed a previous version of Nim using choosenim,
getting Nim 2.0 is as easy as:
$ choosenim update stable

Alternative…]]></summary>
        <author>
            <name>Nim Programming Language</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[On Modularity of Lexical Analysis]]></title>
        <id>https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html</id>
        <link href="https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html"/>
        <updated>2023-08-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[I was going to write a long post about designing an IDE-friendly language. I wrote an intro and
figured that it would make a better, shorter post on its own. Enjoy!]]></summary>
        <author>
            <name>matklad</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA["Once" one-time concurrent initialization with an integer]]></title>
        <id>https://nullprogram.com/blog/2023/07/31/</id>
        <link href="https://nullprogram.com/blog/2023/07/31/"/>
        <updated>2023-07-31T23:00:41.000Z</updated>
        <summary type="html"><![CDATA[We’ve previously discussed integer barriers, integer queues, and
integer wait groups as tiny concurrency utilities. Next let’s tackle
“once” initialization, i.e. pthread_once, using an integer.
We’ll need only three basic atomic operations — store, load, and increment
— and futex wait/wake. It will be zero-initialized and the entire source
small enough to fit on an old-fashioned terminal display. The interface
will also get an overhaul, more to my own tastes.
If you’d like to skip ahead: once.c
What’s the purpose? Suppose a concurrent program requires initialization,
but has no definite moment to do so. Threads are already in motion, and
it’s unpredictable which will arrive first, and when. It might be because
this part of the program is loaded lazily, or initialization is expensive
and on…]]></summary>
        <author>
            <name>null program</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Hμblog] Make the web great again]]></title>
        <id>https://www.devever.net/~hl/u/202307#29a</id>
        <link href="https://www.devever.net/~hl/u/202307#29a"/>
        <updated>2023-07-29T15:48:47.000Z</updated>
        <summary type="html"><![CDATA[<div type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><ul><li><a href="https://koshka.love/mwwwga.html">Make the web great again</a></li><li><a href="https://koshka.love/babel/irc-forever.html">IRC is the only viable chat protocol</a></li><li><a href="https://koshka.love/babel/normiefication.html">How "Normiefication" causes everything to go to the dogs</a></li></ul><p xmlns="http://www.w3.org/1999/xhtml">Interesting writings by Koshka, who has a fantastic Web 1.0/Geocities-esque
website of great depth and variation.</p></div></div>]]></summary>
        <author>
            <name>devever.net/~hl</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Functions are Vectors]]></title>
        <id>https://thenumb.at/Functions-are-Vectors/</id>
        <link href="https://thenumb.at/Functions-are-Vectors/"/>
        <updated>2023-07-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Conceptualizing functions as infinite-dimensional vectors lets us apply the tools of linear algebra to a vast landscape of new problems, from image and geometry processing to curve fitting, light transport, and machine learning. Prerequisites: introductory linear algebra, introductory calculus, introductory differential equations. Functions as Vectors Vector Spaces Linear Operators Diagonalization Inner Product Spaces The Spectral Theorem Applications Fourier Series Image Compression Geometry Processing Further Reading Functions as Vectors Vectors are often first introduced as lists of real numbers—i.e. the familiar notation we use for points, directions, and more. $$ \mathbf{v} = \begin{bmatrix}x\\y\\z\end{bmatrix} $$ You may recall that this representation is only one example of an abstract vector space. There are many other types of vectors, such as lists of complex numbers, graph cycles, and even magic squares. However, all of these vector spaces have one thing in common: a finite number of dimensions. That is, each kind of vector can be represented as a collection of \(N\) numbers, though the definition of “number” varies. If any \(N\)-dimensional vector is essentially a length-\(N\) list, we could also consider a vector to be a mapping from an index to a value. \[\begin{align*} \mathbf{v}_1 &amp;= x\\ \mathbf{v}_2 &amp;= y\\ \mathbf{v}_3 &amp;= z \end{align*}\ \iff\ \mathbf{v} = \begin{bmatrix}x \\ y \\ z\end{bmatrix}\] What does this perspective hint at as we increase the number of dimensions? Dimensions In higher dimensions, vectors start to look more like functions! Countably Infinite Indices Of course, a finite-length vector only specifies a value at a limited number of indices. Could we instead define a vector that contains infinitely many values? Writing down a vector representing a function on the natural numbers (\(\mathbb{N}\))—or any other countably infinite domain—is straightforward: just extend the list indefinitely. $$ \begin{align*}\mathbf{v}_1 &amp;= 1\\\mathbf{v}_2 &amp;= 2\\ &amp;\vdots \\ \mathbf{v}_i &amp;= i\end{align*}\ \iff\ \mathbf{v} = \begin{bmatrix}1 \\ 2 \\ 3 \\ \vdots \end{bmatrix} $$ This vector could represent the function \(f(x) = x\), where \(x \in \mathbb{N}\).1 Uncountably Infinite Indices Many interesting functions are defined on the real numbers (\(\mathbb{R}\)), so may not be representable as a countably infinite vector. Therefore, we will have to make a larger conceptual leap: not only will our set of indices be infinite, it will be uncountably infinite. That means we can’t write down vectors as lists at all—it is impossible to assign an integer index to each element of an uncountable set. So, how can we write down a vector mapping a real index to a certain value? Now, a vector really is just an arbitrary function: $$ \mathbf{v}_{x} = x^2\ \iff\ \mathbf{v} = \begin{bmatrix} x \mapsto x^2 \end{bmatrix} $$ Precisely defining how and why we can represent functions as infinite-dimensional vectors is the purview of functional analysis. In this post, we won’t attempt to prove our results in infinite dimensions: we will focus on building intuition via analogies to finite-dimensional linear algebra. Vector Spaces Review: Abstract vector spaces | Chapter 16, Essence of linear algebra. Formally, a vector space is defined by choosing a set of vectors \(\mathcal{V}\), a scalar field \(\mathbb{F}\), and a zero vector \(\mathbf{0}\). The field \(\mathbb{F}\) is often the real numbers (\(\mathbb{R}\)), complex numbers (\(\mathbb{C}\)), or a finite field such as the integers modulo a prime (\(\mathbb{Z}_p\)). Additionally, we must specify how to add two vectors and how to multiply a vector by a scalar. \[\begin{align*} (+)\ &amp;:\ \mathcal{V}\times\mathcal{V}\mapsto\mathcal{V}\\ (\cdot)\ &amp;:\ \mathbb{F}\times\mathcal{V} \mapsto \mathcal{V} \end{align*}\] To describe a vector space, our definitions must entail several vector space axioms. A Functional Vector Space In the following sections, we’ll work with the vector space of real functions. To avoid ambiguity, square brackets are used to denote function application. The scalar field \(\mathbb{F}\) is the real numbers \(\mathbb{R}\). The set of vectors \(\mathcal{V}\) contains functions from \(\mathbb{R}\) to \(\mathbb{R}\).2 \(\mathbf{0}\) is the zero function, i.e. \(\mathbf{0}[x] = 0\). Adding functions corresponds to applying the functions separately and summing the results. $$ (f + g)[x] = f[x] + g[x] $$ This definition generalizes the typical element-wise addition rule—it’s like adding the two values at each index. \[f+g = \begin{bmatrix}f_1 + g_1 \\ f_2 + g_2 \\ \vdots \end{bmatrix}\] Multiplying a function by a scalar corresponds to applying the function and scaling the result. $$ (\alpha f)[x] = \alpha f[x] $$ This rule similarly generalizes element-wise multiplication—it’s like scaling the value at each index. \[\alpha f = \begin{bmatrix}\alpha f_1 \\ \alpha f_2 \\ \vdots \end{bmatrix}\] Proofs Given these definitions, we can now prove all necessary vector space axioms. We will illustrate the analog of each property in \(\mathbb{R}^2\), the familiar vector space of two-dimensional arrows. Vector Addition is Commutative For all vectors $$\mathbf{u}, \mathbf{v} \in \mathcal{V}$$: $$\mathbf{u} + \mathbf{v} = \mathbf{v} + \mathbf{u}$$ Since real addition is commutative, this property follows directly from our definition of vector addition: $$\begin{align*} (f + g)[x] &amp;= f[x] + g[x]\\ &amp;= g[x] + f[x]\\ &amp;= (g + f)[x] \end{align*}$$ Vector Addition is Associative For all vectors $$\mathbf{u}, \mathbf{v}, \mathbf{w} \in \mathcal{V}$$: $$(\mathbf{u} + \mathbf{v}) + \mathbf{w} = \mathbf{u} + (\mathbf{v} + \mathbf{w})$$ This property also follows from our definition of vector addition: $$\begin{align*} ((f + g) + h)[x] &amp;= (f + g)[x] + h[x]\\ &amp;= f[x] + g[x] + h[x]\\ &amp;= f[x] + (g[x] + h[x])\\ &amp;= f[x] + (g + h)[x]\\ &amp;= (f + (g + h))[x] \end{align*}$$ $$\mathbf{0}$$ is an Additive Identity For all vectors $$\mathbf{u} \in \mathcal{V}$$: $$\mathbf{0} + \mathbf{u} = \mathbf{u} $$ This one is easy: $$\begin{align*} (\mathbf{0} + f)[x] &amp;= \mathbf{0}[x] + f[x]\\ &amp;= 0 + f[x]\\ &amp;= f[x] \end{align*}$$ Additive Inverses Exist For all vectors $$\mathbf{u} \in \mathcal{V}$$, there exists a vector $$-\mathbf{u} \in \mathcal{V}$$ such that: $$\mathbf{u} + (-\mathbf{u}) = \mathbf{0}$$ Negation is defined as applying $$f$$ and negating the result: $$(-f)[x] = -f[x]$$. Clearly, $$-f$$ is also in $$\mathcal{V}$$. $$\begin{align*} (f + (-f))[x] &amp;= f[x] + (-f)[x]\\ &amp;= f[x] - f[x]\\ &amp;= 0\\ &amp;= \mathbf{0}[x] \end{align*}$$ $$1$$ is a Multiplicative Identity For all vectors $$\mathbf{u} \in \mathcal{V}$$: $$1\mathbf{u} = \mathbf{u}$$ Note that $$1$$ is specified by the choice of $$\mathbb{F}$$. In our case, it is simply the real number $$1$$. $$\begin{align*} (1 f)[x] &amp;= 1 f[x]\\ &amp;= f[x] \end{align*}$$ Scalar Multiplication is Associative For all vectors $$\mathbf{u} \in \mathcal{V}$$ and scalars $$\alpha, \beta \in \mathbb{F}$$: $$(\alpha \beta)\mathbf{u} = \alpha(\beta\mathbf{u})$$ This property follows from our definition of scalar multiplication: $$\begin{align*} ((\alpha\beta) f)[x] &amp;= (\alpha\beta)f[x]\\ &amp;= \alpha(\beta f[x])\\ &amp;= \alpha(\beta f)[x] \end{align*}$$ Scalar Multiplication Distributes Over Vector Addition For all vectors $$\mathbf{u}, \mathbf{v} \in \mathcal{V}$$ and scalars $$\alpha \in \mathbb{F}$$: $$\alpha(\mathbf{u} + \mathbf{v}) = \alpha\mathbf{u} + \alpha\mathbf{v}$$ Again using our definitions of vector addition and scalar multiplication: $$\begin{align*} (\alpha (f + g))[x] &amp;= \alpha(f + g)[x]\\ &amp;= \alpha(f[x] + g[x])\\ &amp;= \alpha f[x] + \alpha g[x]\\ &amp;= (\alpha f)[x] + (\alpha g)[x]\\ &amp;= (\alpha f + \alpha g)[x] \end{align*}$$ Scalar Multiplication Distributes Over Scalar Addition For all vectors $$\mathbf{u} \in \mathcal{V}$$ and scalars $$\alpha, \beta \in \mathbb{F}$$: $$(\alpha + \beta)\mathbf{u} = \alpha\mathbf{u} + \beta\mathbf{u}$$ Again using our definitions of vector addition and scalar multiplication: $$\begin{align*} ((\alpha + \beta)f)[x] &amp;= (\alpha + \beta)f[x]\\ &amp;= \alpha f[x] + \beta f[x] \\ &amp;= (\alpha f)[x] + (\beta f)[x] \end{align*}$$ Therefore, we’ve built a vector space of functions!3 It may not be immediately obvious why this result is useful, but bear with us through a few more definitions—we will spend the rest of this post exploring powerful techniques arising from this perspective. A Standard Basis for Functions Review: Linear combinations, span, and basis vectors | Chapter 2, Essence of linear algebra. Unless specified otherwise, vectors are written down with respect to the standard basis. In \(\mathbb{R}^2\), the standard basis consists of the two coordinate axes. $$ \mathbf{e}_1 = \begin{bmatrix}1 \\ 0\end{bmatrix},\,\, \mathbf{e}_2 = \begin{bmatrix}0 \\ 1\end{bmatrix} $$ Hence, vector notation is shorthand for a linear combination of the standard basis vectors. $$ \mathbf{u} = \begin{bmatrix}\alpha \\ \beta\end{bmatrix} = \alpha\mathbf{e}_1 + \beta\mathbf{e}_2 $$ Above, we represented functions as vectors by assuming each dimension of an infinite-length vector contains the function’s result for that index. This construction points to a natural generalization of the standard basis. Just like the coordinate axes, each standard basis function contains a \(1\) at one index and \(0\) everywhere else. More precisely, for every \(\alpha \in \mathbb{R}\): \[\mathbf{e}_\alpha[x] = \begin{cases} 1 &amp; \text{if } x = \alpha \\ 0 &amp; \text{otherwise} \end{cases}\] Ideally, we could express an arbitrary function \(f\) as a linear combination of these basis functions. However, there are uncountably many of them—and we can’t simply write down a sum over the reals. Still, considering their linear combination is illustrative: \[\begin{align*} f[x] &amp;= f[\alpha]\mathbf{e}_\alpha[x] \\ &amp;= f[1]\mathbf{e}_1[x] + f[2]\mathbf{e}_2[x] + f[\pi]\mathbf{e}_\pi[x] + \dots \end{align*}\] If we evaluate this “sum” at \(x\), we’ll find that all terms are zero—except \(\mathbf{e}_x\), making the result \(f[x]\). Linear Operators Review: Change of basis | Chapter 13, Essence of linear algebra. Now that we can manipulate functions as vectors, let’s start transferring the tools of linear algebra to the functional perspective. One ubiquitous operation on finite-dimensional vectors is transforming them with matrices. A matrix \(\mathbf{A}\) encodes a linear transformation, meaning multiplication preserves linear combinations. \[\mathbf{A}(\alpha \mathbf{x} + \beta \mathbf{y}) = \alpha \mathbf{A}\mathbf{x} + \beta \mathbf{A}\mathbf{y}\] Multiplying a vector by a matrix can be intuitively interpreted as defining a new set of coordinate axes from the matrix’s column vectors. The result is a linear combination of the columns: \[\mathbf{Ax} = \begin{bmatrix} \vert &amp; \vert &amp; \vert \\ \mathbf{u} &amp; \mathbf{v} &amp; \mathbf{w} \\ \vert &amp; \vert &amp; \vert \end{bmatrix} \begin{bmatrix}x_1 \\ x_2 \\ x_3\end{bmatrix} = x_1\mathbf{u} + x_2\mathbf{v} + x_3\mathbf{w}\] \[\begin{align*} \mathbf{Ax} &amp;= \begin{bmatrix} \vert &amp; \vert &amp; \vert \\ \mathbf{u} &amp; \mathbf{v} &amp; \mathbf{w} \\ \vert &amp; \vert &amp; \vert \end{bmatrix} \begin{bmatrix}x_1 \\ x_2 \\ x_3\end{bmatrix} \\ &amp;= x_1\mathbf{u} + x_2\mathbf{v} + x_3\mathbf{w} \end{align*}\] When all vectors can be expressed as a linear combination of \(\mathbf{u}\), \(\mathbf{v}\), and \(\mathbf{w}\), the columns form a basis for the underlying vector space. Here, the matrix \(\mathbf{A}\) transforms a vector from the \(\mathbf{uvw}\) basis into the standard basis. Since functions are vectors, we could imagine transforming a function by a matrix. Such a matrix would be infinite-dimensional, so we will instead call it a linear operator and denote it with \(\mathcal{L}\). \[\mathcal{L}f = \begin{bmatrix} \vert &amp; \vert &amp; \vert &amp; \\ \mathbf{f} &amp; \mathbf{g} &amp; \mathbf{h} &amp; \cdots \\ \vert &amp; \vert &amp; \vert &amp; \end{bmatrix} \begin{bmatrix}f_1\\ f_2 \\ f_3\\ \vdots\end{bmatrix} = f_1\mathbf{f} + f_2\mathbf{g} + f_3\mathbf{h} + \cdots\] \[\begin{align*} \mathcal{L}f &amp;= \begin{bmatrix} \vert &amp; \vert &amp; \vert &amp; \\ \mathbf{f} &amp; \mathbf{g} &amp; \mathbf{h} &amp; \cdots \\ \vert &amp; \vert &amp; \vert &amp; \end{bmatrix} \begin{bmatrix}f_1\\ f_2\\ f_3 \\ \vdots\end{bmatrix} \\ &amp;= f_1\mathbf{f} + f_2\mathbf{g} + f_3\mathbf{h} + \cdots \end{align*}\] This visualization isn’t very accurate—we’re dealing with uncountably infinite-dimensional vectors, so we can’t actually write out an operator in matrix form. Nonetheless, the structure is suggestive: each “column” of the operator describes a new basis function for our functional vector space. Just like we saw with finite-dimensional vectors, \(\mathcal{L}\) represents a change of basis. Differentiation Review: Derivative formulas through geometry | Chapter 3, Essence of calculus. So, what’s an example of a linear operator on functions? You might recall that differentiation is linear: \[\frac{\partial}{\partial x} \left(\alpha f[x] + \beta g[x]\right) = \alpha\frac{\partial f}{\partial x} + \beta\frac{\partial g}{\partial x}\] It’s hard to visualize differentiation on general functions, but it’s feasible for the subspace of polynomials, \(\mathcal{P}\). Let’s take a slight detour to examine this smaller space of functions. \[\mathcal{P} = \{ p[x] = a + bx + cx^2 + dx^3 + \cdots \}\] We typically write down polynomials as a sequence of powers, i.e. \(1, x, x^2, x^3\), etc. All polynomials are linear combinations of the functions \(\mathbf{e}_i[x] = x^i\), so they constitute a countably infinite basis for \(\mathcal{P}\).4 This basis provides a convenient vector notation: \[\begin{align*} p[x] &amp;= a + bx + cx^2 + dx^3 + \cdots \\ &amp;= a\mathbf{e}_0 + b\mathbf{e}_1 + c \mathbf{e}_2 + d\mathbf{e}_3 + \dots \end{align*}\ \iff\ \mathbf{p} = \begin{bmatrix}a\\ b\\ c\\ d\\ \vdots\end{bmatrix}\] \[\begin{align*} p[x] &amp;= a + bx + cx^2 + dx^3 + \cdots \\ &amp;= a\mathbf{e}_0 + b\mathbf{e}_1 + c \mathbf{e}_2 + d\mathbf{e}_3 + \dots \\&amp; \iff\ \mathbf{p} = \begin{bmatrix}a\\ b\\ c\\ d\\ \vdots\end{bmatrix} \end{align*}\] Since differentiation is linear, we’re able to apply the rule \(\frac{\partial}{\partial x} x^n = nx^{n-1}\) to each term. \[\begin{align*}\frac{\partial}{\partial x}p[x] &amp;= \vphantom{\Bigg\vert}a\frac{\partial}{\partial x}1 + b\frac{\partial}{\partial x}x + c\frac{\partial}{\partial x}x^2 + d\frac{\partial}{\partial x}x^3 + \dots \\ &amp;= b + 2cx + 3dx^2 + \cdots\\ &amp;= b\mathbf{e}_0 + 2c\mathbf{e}_1 + 3d\mathbf{e}_2 + \dots\end{align*} \ \iff\ \frac{\partial}{\partial x}\mathbf{p} = \begin{bmatrix}b\\ 2c\\ 3d\\ \vdots\end{bmatrix}\] \[\begin{align*}\frac{\partial}{\partial x}p[x] &amp;= \vphantom{\Bigg\vert}a\frac{\partial}{\partial x}1 + b\frac{\partial}{\partial x}x + c\frac{\partial}{\partial x}x^2\, +\\ &amp; \phantom{=} d\frac{\partial}{\partial x}x^3 + \dots \\ &amp;= b + 2cx + 3dx^2 + \cdots\\ &amp;= b\mathbf{e}_0 + 2c\mathbf{e}_1 + 3d\mathbf{e}_2 + \dots \\ &amp;\iff\ \frac{\partial}{\partial x}\mathbf{p} = \begin{bmatrix}b\\ 2c\\ 3d\\ \vdots\end{bmatrix}\end{align*}\] We’ve performed a linear transformation on the coefficients, so we can represent differentiation as a matrix! \[\frac{\partial}{\partial x}\mathbf{p} = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 &amp; \cdots\\ 0 &amp; 0 &amp; 2 &amp; 0 &amp; \cdots\\ 0 &amp; 0 &amp; 0 &amp; 3 &amp; \cdots\\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots \end{bmatrix}\begin{bmatrix}a\\ b\\ c\\ d\\ \vdots\end{bmatrix} = \begin{bmatrix}b\\ 2c\\ 3d\\ \vdots\end{bmatrix}\] Each column of the differentiation operator is itself a polynomial, so this matrix represents a change of basis. \[\frac{\partial}{\partial x} = \begin{bmatrix} \vert &amp; \vert &amp; \vert &amp; \vert &amp; \vert &amp; \\ 0 &amp; 1 &amp; 2x &amp; 3x^2 &amp; 4x^3 &amp; \cdots \\ \vert &amp; \vert &amp; \vert &amp; \vert &amp; \vert &amp; \end{bmatrix}\] As we can see, the differentiation operator simply maps each basis function to its derivative. This result also applies to the larger space of analytic real functions, which includes polynomials, exponential functions, trigonometric functions, logarithms, and other familiar names. By definition, an analytic function can be expressed as a Taylor series about \(0\): \[f[x] = \sum_{n=0}^\infty \frac{f^{(n)}[0]}{n!}x^n = \sum_{n=0}^\infty \alpha_n x^n\] Which is a linear combination of our polynomial basis functions. That means a Taylor expansion is essentially a change of basis into the sequence of powers, where our differentiation operator is quite simple.5 Diagonalization Review: Eigenvectors and eigenvalues | Chapter 14, Essence of linear algebra. Matrix decompositions are arguably the crowning achievement of linear algebra. To get started, let’s review what diagonalization means for a \(3\times3\) real matrix \(\mathbf{A}\). Eigenvectors A vector \(\mathbf{u}\) is an eigenvector of the matrix \(\mathbf{A}\) when the following condition holds: $$ \mathbf{Au} = \lambda \mathbf{u} $$ The eigenvalue \(\lambda\) may be computed by solving the characteristic polynomial of \(\mathbf{A}\). Eigenvalues may be real or complex. The matrix \(\mathbf{A}\) is diagonalizable when it admits three linearly independent eigenvectors, each with a corresponding real eigenvalue. This set of eigenvectors constitutes an eigenbasis for the underlying vector space, indicating that we can express any vector \(\mathbf{x}\) via their linear combination. $$ \mathbf{x} = \alpha\mathbf{u}_1 + \beta\mathbf{u}_2 + \gamma\mathbf{u}_3 $$ To multiply \(\mathbf{x}\) by \(\mathbf{A}\), we just have to scale each component by its corresponding eigenvalue. $$ \begin{align*} \mathbf{Ax} &amp;= \alpha\mathbf{A}\mathbf{u}_1 + \beta\mathbf{A}\mathbf{u}_2 + \gamma\mathbf{A}\mathbf{u}_3 \\ &amp;= \alpha\lambda_1\mathbf{u}_1 + \beta\lambda_2\mathbf{u}_2 + \gamma\lambda_3\mathbf{u}_3 \end{align*} $$ Finally, re-combining the eigenvectors expresses the result in the standard basis. Intuitively, we’ve shown that multiplying by \(\mathbf{A}\) is equivalent to a change of basis, a scaling, and a change back. That means we can write \(\mathbf{A}\) as the product of an invertible matrix \(\mathbf{U}\) and a diagonal matrix \(\mathbf{\Lambda}\). \[\begin{align*} \mathbf{A} &amp;= \mathbf{U\Lambda U^{-1}} \\ &amp;= \begin{bmatrix}\vert &amp; \vert &amp; \vert \\ \mathbf{u}_1 &amp; \mathbf{u}_2 &amp; \mathbf{u}_3 \\ \vert &amp; \vert &amp; \vert \end{bmatrix} \begin{bmatrix}\lambda_1 &amp; 0 &amp; 0 \\ 0 &amp; \lambda_2 &amp; 0 \\ 0 &amp; 0 &amp; \lambda_3 \end{bmatrix} \begin{bmatrix}\vert &amp; \vert &amp; \vert \\ \mathbf{u}_1 &amp; \mathbf{u}_2 &amp; \mathbf{u}_3 \\ \vert &amp; \vert &amp; \vert \end{bmatrix}^{-1} \end{align*}\] \[\begin{align*} \mathbf{A} &amp;= \mathbf{U\Lambda U^{-1}} \\ &amp;= \begin{bmatrix}\vert &amp; \vert &amp; \vert \\ \mathbf{u}_1 &amp; \mathbf{u}_2 &amp; \mathbf{u}_3 \\ \vert &amp; \vert &amp; \vert \end{bmatrix} \\ &amp; \phantom{=} \begin{bmatrix}\lambda_1 &amp; 0 &amp; 0 \\ 0 &amp; \lambda_2 &amp; 0 \\ 0 &amp; 0 &amp; \lambda_3 \end{bmatrix} \\ &amp; \phantom{=} \begin{bmatrix}\vert &amp; \vert &amp; \vert \\ \mathbf{u}_1 &amp; \mathbf{u}_2 &amp; \mathbf{u}_3 \\ \vert &amp; \vert &amp; \vert \end{bmatrix}^{-1} \end{align*}\] Note that \(\mathbf{U}\) is invertible because its columns (the eigenvectors) form a basis for \(\mathbb{R}^3\). When multiplying by \(\mathbf{x}\), \(\mathbf{U}^{-1}\) converts \(\mathbf{x}\) to the eigenbasis, \(\mathbf{\Lambda}\) scales by the corresponding eigenvalues, and \(\mathbf{U}\) takes us back to the standard basis. In the presence of complex eigenvalues, \(\mathbf{A}\) may still be diagonalizable if we allow \(\mathbf{U}\) and \(\mathbf{\Lambda}\) to include complex entires. In this case, the decomposition as a whole still maps real vectors to real vectors, but the intermediate values become complex. Eigenfunctions Review: What’s so special about Euler’s number e? | Chapter 5, Essence of calculus. So, what does diagonalization mean in a vector space of functions? Given a linear operator \(\mathcal{L}\), you might imagine a corresponding definition for eigenfunctions: \[\mathcal{L}f = \psi f\] The scalar \(\psi\) is again known as an eigenvalue. Since \(\mathcal{L}\) is infinite-dimensional, it doesn’t have a characteristic polynomial—there’s not a straightforward method for computing \(\psi\). Nevertheless, let’s attempt to diagonalize differentiation on analytic functions. The first step is to find the eigenfunctions. Start by applying the above condition to our differentiation operator in the power basis: \[\begin{align*} &amp;&amp; \frac{\partial}{\partial x}\mathbf{p} = \psi \mathbf{p} \vphantom{\Big|}&amp; \\ &amp;\iff&amp; \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 &amp; \cdots\\ 0 &amp; 0 &amp; 2 &amp; 0 &amp; \cdots\\ 0 &amp; 0 &amp; 0 &amp; 3 &amp; \cdots\\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots \end{bmatrix}\begin{bmatrix}p_0\\ p_1\\ p_2\\ p_3\\ \vdots\end{bmatrix} &amp;= \begin{bmatrix}\psi p_0\\ \psi p_1 \\ \psi p_2 \\ \psi p_3 \\ \vdots \end{bmatrix} \\ &amp;\iff&amp; \begin{cases} p_1 &amp;= \psi p_0 \\ p_2 &amp;= \frac{\psi}{2} p_1 \\ p_3 &amp;= \frac{\psi}{3} p_2 \\ &amp;\dots \end{cases} &amp; \end{align*}\] This system of equations implies that all coefficients are determined solely by our choice of constants \(p_0\) and \(\psi\). We can explicitly write down their relationship as \(p_i = \frac{\psi^i}{i!}p_0\). Now, let’s see what this class of polynomials actually looks like. \[p[x] = p_0 + p_0\psi x + p_0\frac{\psi^2}{2}x^2 + p_0\frac{\psi^3}{6}x^3 + p_0\frac{\psi^4}{24}x^4 + \dots\] \[\begin{align*} p[x] &amp;= p_0 + p_0\psi x + p_0\frac{\psi^2}{2}x^2\, +\\ &amp;\phantom{=} p_0\frac{\psi^3}{6}x^3 + p_0\frac{\psi^4}{24}x^4 + \dots \end{align*}\] Differentiation shows that this function is, in fact, an eigenfunction for the eigenvalue \(\psi\). \[\begin{align*} \frac{\partial}{\partial x} p[x] &amp;= 0 + p_0\psi + p_0 \psi^2 x + p_0\frac{\psi^3}{2}x^2 + p_0\frac{\psi^4}{6}x^3 + \dots \\ &amp;= \psi p[x] \end{align*}\] \[\begin{align*} \frac{\partial}{\partial x} p[x] &amp;= 0 + p_0\psi + p_0 \psi^2 x\, +\\ &amp;\phantom{=} p_0\frac{\psi^3}{2}x^2 + p_0\frac{\psi^4}{6}x^3 + \dots \\ &amp;= \psi p[x] \end{align*}\] With a bit of algebraic manipulation, the definition of \(e^{x}\) pops out: \[\begin{align*} p[x] &amp;= p_0 + p_0\psi x + p_0\frac{\psi^2}{2}x^2 + p_0\frac{\psi^3}{6}x^3 + p_0\frac{\psi^4}{24}x^4 + \dots \\ &amp;= p_0\left((\psi x) + \frac{1}{2!}(\psi x)^2 + \frac{1}{3!}(\psi x)^3 + \frac{1}{4!}(\psi x)^4 + \dots\right) \\ &amp;= p_0 e^{\psi x} \end{align*}\] \[\begin{align*} p[x] &amp;= p_0 + p_0\psi x + p_0\frac{\psi^2}{2}x^2\, +\\ &amp;\phantom{=} p_0\frac{\psi^3}{6}x^3 + p_0\frac{\psi^4}{24}x^4 + \dots \\ &amp;= p_0\Big((\psi x) + \frac{1}{2!}(\psi x)^2\, +\\ &amp;\phantom{=p_0\Big((} \frac{1}{3!}(\psi x)^3 + \frac{1}{4!}(\psi x)^4 + \dots\Big) \\ &amp;= p_0 e^{\psi x} \end{align*}\] Therefore, functions of the form \(p_0e^{\psi x}\) are eigenfunctions for the eigenvalue \(\psi\), including when \(\psi=0\). Diagonalizing Differentiation We’ve found the eigenfunctions of the derivative operator, but can we diagonalize it? Ideally, we would express differentiation as the combination of an invertible operator \(\mathcal{L}\) and a diagonal operator \(\mathcal{D}\). \[\begin{align*} \frac{\partial}{\partial x} &amp;= \mathcal{L} \mathcal{D} \mathcal{L}^{-1} \\ &amp;= \begin{bmatrix} \vert &amp; \vert &amp; &amp; \\ \alpha e^{\psi_1 x} &amp; \beta e^{\psi_2 x} &amp; \dots \\ \vert &amp; \vert &amp; \end{bmatrix} \begin{bmatrix} \psi_1 &amp; 0 &amp; \dots \\ 0 &amp; \psi_2 &amp; \dots \\ \vdots &amp; \vdots &amp; \ddots \end{bmatrix} {\color{red} \begin{bmatrix} \vert &amp; \vert &amp; &amp; \\ \alpha e^{\psi_1 x} &amp; \beta e^{\psi_2 x} &amp; \dots \\ \vert &amp; \vert &amp; \end{bmatrix}^{-1} } \end{align*}\] \[\begin{align*} \frac{\partial}{\partial x} &amp;= \mathcal{L} \mathcal{D} \mathcal{L}^{-1} \\ &amp;= \begin{bmatrix} \vert &amp; \vert &amp; &amp; \\ \alpha e^{\psi_1 x} &amp; \beta e^{\psi_2 x} &amp; \dots \\ \vert &amp; \vert &amp; \end{bmatrix} \\ &amp; \phantom{=} \begin{bmatrix} \psi_1 &amp; 0 &amp; \dots \\ 0 &amp; \psi_2 &amp; \dots \\ \vdots &amp; \vdots &amp; \ddots \end{bmatrix} \\ &amp; \phantom{=} {\color{red} \begin{bmatrix} \vert &amp; \vert &amp; &amp; \\ \alpha e^{\psi_1 x} &amp; \beta e^{\psi_2 x} &amp; \dots \\ \vert &amp; \vert &amp; \end{bmatrix}^{-1} } \end{align*}\] Diagonalization is only possible when our eigenfunctions form a basis. This would be true if all analytic functions are expressible as a linear combination of exponentials. However… Counterexample: $$f[x] = x$$ First assume that \(f[x] = x\) can be represented as a linear combination of exponentials. Since analytic functions have countably infinite dimensionality, we should only need a countably infinite sum: \[f[x] = x = \sum_{n=0}^\infty \alpha_n e^{\psi_n x}\] Differentiating both sides: \[\begin{align*} f^{\prime}[x] &amp;= 1 = \sum_{n=0}^\infty \psi_n\alpha_n e^{\psi_n x} \\ f^{\prime\prime}[x] &amp;= 0 = \sum_{n=0}^\infty \psi_n^2\alpha_n e^{\psi_n x} \end{align*}\] Since \(e^{\psi_n x}\) and \(e^{\psi_m x}\) are linearly independent when \(n\neq m\), the final equation implies that all \(\alpha = 0\), except possibly the \(\alpha_\xi\) corresponding to \(\psi_\xi = 0\). Therefore: \[\begin{align*} 1 &amp;= \sum_{n=0}^\infty \psi_n\alpha_n e^{\psi_n x}\\ &amp;= \psi_\xi \alpha_\xi + \sum_{n\neq \xi} 0\psi_n e^{\psi_n x} \\ &amp;= 0 \end{align*}\] That’s a contradiction—the linear combination representing \(f[x] = x\) does not exist. A similar argument shows that we can’t represent any non-constant function whose \(n\)th derivative is zero, nor periodic functions like sine and cosine. Real exponentials don’t constitute a basis, so we cannot construct an invertible \(\mathcal{L}\). The Laplace Transform We previously mentioned that more matrices can be diagonalized if we allow the decomposition to contain complex numbers. Analogously, more linear operators are diagonalizable in the larger vector space of functions from \(\mathbb{R}\) to \(\mathbb{C}\). Differentiation works the same way in this space; we’ll still find that its eigenfunctions are exponential. \[\frac{\partial}{\partial x} e^{(a+bi)x} = (a+bi)e^{(a+bi)x}\] However, the new eigenfunctions have complex eigenvalues, so we still can’t diagonalize. We’ll need to consider the still larger space of functions from \(\mathbb{C}\) to \(\mathbb{C}\). \[\frac{\partial}{\partial x} : (\mathbb{C}\mapsto\mathbb{C}) \mapsto (\mathbb{C}\mapsto\mathbb{C})\] In this space, differentiation can be diagonalized via the Laplace transform. Although useful for solving differential equations, the Laplace transform is non-trivial to invert, so we won’t discuss it further. In the following sections, we’ll delve into an operator that can be easily diagonalized in \(\mathbb{R}\mapsto\mathbb{C}\): the Laplacian. Inner Product Spaces Review: Dot products and duality | Chapter 9, Essence of linear algebra. Before we get to the spectral theorem, we’ll need to understand one more topic: inner products. You’re likely already familiar with one example of an inner product—the Euclidean dot product. \[\begin{bmatrix}x\\ y\\ z\end{bmatrix} \cdot \begin{bmatrix}a\\ b\\ c\end{bmatrix} = ax + by + cz\] An inner product describes how to measure a vector along another vector. For example, \(\mathbf{u}\cdot\mathbf{v}\) is proportional to the length of the projection of \(\mathbf{u}\) onto \(\mathbf{v}\). $$ \mathbf{u} \cdot \mathbf{v} =\|\mathbf{u}\|\|\mathbf{v}\|\cos[\theta] $$ With a bit of trigonometry, we can show that the dot product is equivalent to multiplying the vectors’ lengths with the cosine of their angle. This relationship suggests that the product of a vector with itself produces the square of its length. \[\begin{align*} \mathbf{u}\cdot\mathbf{u} &amp;= \|\mathbf{u}\|\|\mathbf{u}\|\cos[0] \\ &amp;= \|\mathbf{u}\|^2 \end{align*}\] Similarly, when two vectors form a right angle (are orthogonal), their dot product is zero. $$ \begin{align*} \mathbf{u} \cdot \mathbf{v} &amp;= \|\mathbf{u}\|\|\mathbf{v}\|\cos[90^\circ] \\ &amp;= 0 \end{align*} $$ Of course, the Euclidean dot product is only one example of an inner product. In more general spaces, the inner product is denoted using angle brackets, such as \(\langle \mathbf{u}, \mathbf{v} \rangle\). The length (also known as the norm) of a vector is defined as \(\|\mathbf{u}\| = \sqrt{\langle \mathbf{u}, \mathbf{u} \rangle}\). Two vectors are orthogonal if their inner product is zero: \(\ \mathbf{u} \perp \mathbf{v}\ \iff\ \langle \mathbf{u}, \mathbf{v} \rangle = 0\). A vector space augmented with an inner product is known as an inner product space. A Functional Inner Product We can’t directly apply the Euclidean dot product to our space of real functions, but its \(N\)-dimensional generalization is suggestive. \[\begin{align*} \mathbf{u} \cdot \mathbf{v} &amp;= u_1v_1 + u_2v_2 + \dots + u_Nv_N \\ &amp;= \sum_{i=1}^N u_iv_i \end{align*}\] Given countable indices, we simply match up the values, multiply them, and add the results. When indices are uncountable, we can convert the discrete sum to its continuous analog: an integral! \[\langle f, g \rangle = \int_a^b f[x]g[x] \, dx\] When \(f\) and \(g\) are similar, multiplying them produces a larger function; when they’re different, they cancel out. Integration measures their product over some domain to produce a scalar result. Of course, not all functions can be integrated. Our inner product space will only contain functions that are square integrable over the domain \([a, b]\), which may be \([-\infty, \infty]\). Luckily, the important properties of our inner product do not depend on the choice of integration domain. Proofs Below, we’ll briefly cover functions from \(\mathbb{R}\) to \(\mathbb{C}\). In this space, our intuitive notion of similarity still applies, but we’ll use a slightly more general inner product: \[\langle f,g \rangle = \int_a^b f[x]\overline{g[x]}\, dx\] Where \(\overline{x}\) denotes conjugation, i.e. \(\overline{a + bi} = a - bi\). Like other vector space operations, an inner product must satisfy several axioms: Conjugate Symmetry For all vectors $$\mathbf{u}, \mathbf{v} \in \mathcal{V}$$: $$\langle \mathbf{u}, \mathbf{v} \rangle = \overline{\langle \mathbf{v}, \mathbf{u} \rangle}$$ Conjugation may be taken outside the integral, making this one easy: $$\begin{align*} \langle f, g \rangle &amp;= \int_a^b f[x]\overline{g[x]} \, dx \\ &amp;= \int_a^b \overline{g[x]\overline{f[x]}} \, dx \\ &amp;= \overline{\int_a^b g[x]\overline{f[x]} \, dx} \\ &amp;= \overline{\langle g, f \rangle} \end{align*}$$ Note that we require conjugate symmetry because it implies $$\langle\mathbf{u}, \mathbf{u}\rangle = \overline{\langle\mathbf{u}, \mathbf{u}\rangle}$$, i.e. the inner product of a vector with itself is real. Linearity in the First Argument For all vectors $$\mathbf{u}, \mathbf{v}, \mathbf{w} \in \mathcal{V}$$ and scalars $$\alpha, \beta \in \mathbb{F}$$: $$\langle \alpha \mathbf{u} + \beta \mathbf{v}, \mathbf{w} \rangle = \alpha\langle \mathbf{u}, \mathbf{w} \rangle + \beta\langle \mathbf{v}, \mathbf{w} \rangle $$ The proof follows from linearity of integration, as well as our vector space axioms: \[\begin{align*} \langle \alpha f + \beta g, h \rangle &amp;= \int_a^b (\alpha f + \beta g)[x]\overline{h[x]} \, dx \\ &amp;= \int_a^b (\alpha f[x] + \beta g[x])\overline{h[x]} \, dx \\ &amp;= \int_a^b \alpha f[x]\overline{h[x]} + \beta g[x]\overline{h[x]} \, dx \\ &amp;= \alpha\int_a^b f[x]\overline{h[x]}\, dx + \beta\int_a^b g[x]\overline{h[x]} \, dx \\ &amp;= \alpha\langle f, h \rangle + \beta\langle g, h \rangle \end{align*}\] \[\begin{align*} &amp;\langle \alpha f + \beta g, h \rangle\\ &amp;= \int_a^b (\alpha f + \beta g)[x]\overline{h[x]} \, dx \\ &amp;= \int_a^b (\alpha f[x] + \beta g[x])\overline{h[x]} \, dx \\ &amp;= \int_a^b \alpha f[x]\overline{h[x]} + \beta g[x]\overline{h[x]} \, dx \\ &amp;= \alpha\int_a^b f[x]\overline{h[x]}\, dx\, +\\&amp;\hphantom{==} \beta\int_a^b g[x]\overline{h[x]} \, dx \\ &amp;= \alpha\langle f, h \rangle + \beta\langle g, h \rangle \end{align*}\] Given conjugate symmetry, an inner product is also antilinear in the second argument. Positive-Definiteness For all $$\mathbf{u} \in \mathcal{V}$$: $$ \begin{cases} \langle \mathbf{u}, \mathbf{u} \rangle = 0 &amp; \text{if } \mathbf{u} = \mathbf{0} \\ \langle \mathbf{u}, \mathbf{u} \rangle &gt; 0 &amp; \text{otherwise} \end{cases} $$ By conjugate symmetry, we know $$\langle f, f \rangle$$ is real, so we can compare it with zero. However, rigorously proving this result requires measure-theoretic concepts beyond the scope of this post. In brief, we redefine $$\mathbf{0}$$ not as specifically $$\mathbf{0}[x] = 0$$, but as an equivalence class of functions that are zero "almost everywhere." If $$f$$ is zero almost everywhere, it is only non-zero on a set of measure zero, and therefore integrates to zero. After partitioning our set of functions into equivalence classes, all non-zero functions square-integrate to a positive value. This implies that every function has a real norm, $$\sqrt{\langle f, f \rangle}$$. Along with the definition \(\|f\| = \sqrt{\langle f, f \rangle}\), these properties entail a variety of important results, including the Cauchy–Schwarz and triangle inequalities. The Spectral Theorem Diagonalization is already a powerful technique, but we’re building up to an even more important result regarding orthonormal eigenbases. In an inner product space, an orthonormal basis must satisfy two conditions: each vector is unit length, and all vectors are mutually orthogonal. $$ \begin{cases} \langle\mathbf{u}_i,\mathbf{u}_i\rangle = 1 &amp; \forall i \\ \langle \mathbf{u}_i, \mathbf{u}_j \rangle = 0 &amp; \forall i \neq j \end{cases} $$ A matrix consisting of orthonormal columns is known as an orthogonal matrix. Orthogonal matrices represent rotations of the standard basis. In an inner product space, matrix-vector multiplication computes the inner product of the vector with each row of the matrix. Something interesting happens when we multiply an orthogonal matrix \(\mathbf{U}\) by its transpose: \[\begin{align*} \mathbf{U}^T\mathbf{U} &amp;= \begin{bmatrix}\text{---} &amp; \mathbf{u}_1 &amp; \text{---} \\ \text{---} &amp; \mathbf{u}_2 &amp; \text{---} \\ \text{---} &amp; \mathbf{u}_3 &amp; \text{---} \end{bmatrix} \begin{bmatrix}\vert &amp; \vert &amp; \vert \\ \mathbf{u}_1 &amp; \mathbf{u}_2 &amp; \mathbf{u}_3 \\ \vert &amp; \vert &amp; \vert \end{bmatrix} \\ &amp;= \begin{bmatrix} \langle \mathbf{u}_1, \mathbf{u}_1 \rangle &amp; \langle \mathbf{u}_1, \mathbf{u}_2 \rangle &amp; \langle \mathbf{u}_1, \mathbf{u}_3 \rangle \\ \langle \mathbf{u}_2, \mathbf{u}_1 \rangle &amp; \langle \mathbf{u}_2, \mathbf{u}_2 \rangle &amp; \langle \mathbf{u}_2, \mathbf{u}_3 \rangle \\ \langle \mathbf{u}_3, \mathbf{u}_1 \rangle &amp; \langle \mathbf{u}_3, \mathbf{u}_2 \rangle &amp; \langle \mathbf{u}_3, \mathbf{u}_3 \rangle \end{bmatrix} \\ &amp;= \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \\ &amp;= \mathcal{I} \end{align*}\] Since \(\mathbf{U}^T\mathbf{U} = \mathcal{I}\) (and \(\mathbf{U}\mathbf{U}^T = \mathcal{I}\)), we’ve found that the transpose of \(\mathbf{U}\) is equal to its inverse. When diagonalizing \(\mathbf{A}\), we used \(\mathbf{U}\) to transform vectors from our eigenbasis to the standard basis. Conversely, its inverse transformed vectors from the standard basis to our eigenbasis. If \(\mathbf{U}\) happens to be orthogonal, transforming a vector \(\mathbf{x}\) into the eigenbasis is equivalent to projecting \(\mathbf{x}\) onto each eigenvector. $$ \mathbf{U}^{-1}\mathbf{x} = \mathbf{U}^T\mathbf{x} = \begin{bmatrix}\langle \mathbf{u}_1, \mathbf{x} \rangle \\ \langle \mathbf{u}_2, \mathbf{x} \rangle \\ \langle \mathbf{u}_3, \mathbf{x} \rangle \end{bmatrix} $$ Additionally, the diagonalization of \(\mathbf{A}\) becomes quite simple: \[\begin{align*} \mathbf{A} &amp;= \mathbf{U\Lambda U^T} \\ &amp;= \begin{bmatrix}\vert &amp; \vert &amp; \vert \\ \mathbf{u}_1 &amp; \mathbf{u}_2 &amp; \mathbf{u}_3 \\ \vert &amp; \vert &amp; \vert \end{bmatrix} \begin{bmatrix}\lambda_1 &amp; 0 &amp; 0 \\ 0 &amp; \lambda_2 &amp; 0 \\ 0 &amp; 0 &amp; \lambda_3 \end{bmatrix} \begin{bmatrix}\text{---} &amp; \mathbf{u}_1 &amp; \text{---} \\ \text{---} &amp; \mathbf{u}_2 &amp; \text{---} \\ \text{---} &amp; \mathbf{u}_3 &amp; \text{---} \end{bmatrix} \end{align*}\] \[\begin{align*} \mathbf{A} &amp;= \mathbf{U\Lambda U^T} \\ &amp;= \begin{bmatrix}\vert &amp; \vert &amp; \vert \\ \mathbf{u}_1 &amp; \mathbf{u}_2 &amp; \mathbf{u}_3 \\ \vert &amp; \vert &amp; \vert \end{bmatrix} \\ &amp;\phantom{=} \begin{bmatrix}\lambda_1 &amp; 0 &amp; 0 \\ 0 &amp; \lambda_2 &amp; 0 \\ 0 &amp; 0 &amp; \lambda_3 \end{bmatrix} \\ &amp;\phantom{=} \begin{bmatrix}\text{---} &amp; \mathbf{u}_1 &amp; \text{---} \\ \text{---} &amp; \mathbf{u}_2 &amp; \text{---} \\ \text{---} &amp; \mathbf{u}_3 &amp; \text{---} \end{bmatrix} \end{align*}\] Given an orthogonal diagonalization of \(\mathbf{A}\), we can deduce that \(\mathbf{A}\) must be symmetric, i.e. \(\mathbf{A} = \mathbf{A}^T\). \[\begin{align*} \mathbf{A}^T &amp;= (\mathbf{U\Lambda U}^T)^T \\ &amp;= {\mathbf{U}^T}^T \mathbf{\Lambda }^T \mathbf{U}^T \\ &amp;= \mathbf{U\Lambda U}^T \\ &amp;= \mathbf{A} \end{align*}\] The spectral theorem states that the converse is also true: \(\mathbf{A}\) is symmetric if and only if it admits an orthonormal eigenbasis with real eigenvalues. Proving this result is somewhat involved in finite dimensions and very involved in infinite dimensions, so we won’t reproduce the proofs here. Self-Adjoint Operators We can generalize the spectral theorem to our space of functions, where it states that a self-adjoint operator admits an orthonormal eigenbasis with real eigenvalues.6 Denoted as \(\mathbf{A}^{\hspace{-0.1em}\star\hspace{0.1em}}\), the adjoint of an operator \(\mathbf{A}\) is defined by the following relationship. \[\langle \mathbf{Ax}, \mathbf{y} \rangle = \langle \mathbf{x}, \mathbf{A}^{\hspace{-0.1em}\star\hspace{0.1em}}\mathbf{y} \rangle\] When \(\mathbf{A} = \mathbf{A}^\star\), we say that \(\mathbf{A}\) is self-adjoint. The adjoint can be thought of as a generalized transpose—but it’s not obvious what that means in infinite dimensions. We will simply use our functional inner product to determine whether an operator is self-adjoint. The Laplace Operator Review: Solving the heat equation | DE3. Earlier, we weren’t able to diagonalize (real) differentiation, so it must not be self-adjoint. Therefore, we will explore another fundamental operator, the Laplacian. There are many equivalent definitions of the Laplacian, but in our space of one-dimensional functions, it’s just the second derivative. We will hence restrict our domain to twice-differentiable functions. \[\Delta f = \frac{\partial^2 f}{\partial x^2}\] We may compute \(\Delta^\star\) using two integrations by parts: \[\begin{align*} \left\langle \Delta f[x], g[x] \right\rangle &amp;= \int_a^b f^{\prime\prime}[x] g[x]\, dx \\ &amp;= f^\prime[x]g[x]\Big|_a^b - \int_a^b f^{\prime}[x] g^{\prime}[x]\, dx \\ &amp;= (f^\prime[x]g[x] - f[x]g^{\prime}[x])\Big|_a^b + \int_a^b f[x] g^{\prime\prime}[x]\, dx \\ &amp;= \left\langle f[x], \Delta g[x] \right\rangle \end{align*}\] \[\begin{align*} \left\langle \Delta f[x], g[x] \right\rangle &amp;= \int_a^b f^{\prime\prime}[x] g[x]\, dx \\ &amp;= f^\prime[x]g[x]\Big|_a^b - \int_a^b f^{\prime}[x] g^{\prime}[x]\, dx \\ &amp;= (f^\prime[x]g[x] - f[x]g^{\prime}[x])\Big|_a^b \\&amp;\hphantom{=}+ \int_a^b f[x] g^{\prime\prime}[x]\, dx \\ &amp;= \left\langle f[x], \Delta g[x] \right\rangle \end{align*}\] In the final step, we assume that \((f^\prime[x]g[x] - f[x]g^{\prime}[x])\big|_a^b = 0\), which is not true in general. To make our conclusion valid, we will constrain our domain to only include functions satisfying this boundary condition. Specifically, we will only consider periodic functions with period \(b-a\). These functions have the same value and derivative at \(a\) and \(b\), so the additional term vanishes. For simplicity, we will also assume our domain to be \([0,1]\). For example: Therefore, the Laplacian is self-adjoint…almost. Technically, we’ve shown that the Laplacian is symmetric, not that \(\Delta = \Delta^\star\). This is a subtle point, and it’s possible to prove self-adjointness, so we will omit this detail. Laplacian Eigenfunctions Review: e^(iπ) in 3.14 minutes, using dynamics | DE5. Applying the spectral theorem tells us that the Laplacian admits an orthonormal eigenbasis. Let’s find it.7 Since the Laplacian is simply the second derivative, real exponentials would still be eigenfunctions—but they’re not periodic, so we’ll have to exclude them. \[\color{red} \Delta e^{\psi x} = \psi^2 e^{\psi x}\] Luckily, a new class of periodic eigenfunctions appears: \[\begin{align*} \Delta \sin[\psi x] &amp;= -\psi^2 \sin[\psi x] \\ \Delta \cos[\psi x] &amp;= -\psi^2 \cos[\psi x] \end{align*}\] If we allow our diagonalization to introduce complex numbers, we can also consider functions from \(\mathbb{R}\) to \(\mathbb{C}\) . Here, purely complex exponentials are eigenfunctions with real eigenvalues. \[\begin{align*} \Delta e^{\psi i x} &amp;= (\psi i)^2e^{\psi i x} \\ &amp;= -\psi^2 e^{\psi i x} \\ &amp;= -\psi^2 (\cos[\psi x] + i\sin[\psi x]) \tag{Euler's formula} \end{align*}\] \[\begin{align*} \Delta e^{\psi i x} &amp;= (\psi i)^2e^{\psi i x} \\ &amp;= -\psi^2 e^{\psi i x} \\ &amp;= -\psi^2 (\cos[\psi x] + i\sin[\psi x]) \\&amp; \tag{Euler's formula} \end{align*}\] Using Euler’s formula, we can see that these two perspectives are equivalent: they both introduce \(\sin\) and \(\cos\) as eigenfunctions. Either path can lead to our final result, but we’ll stick with the more compact complex case. We also need to constrain the set of eigenfunctions to be periodic on \([0,1]\). As suggested above, we can pick out the eigenvalues that are an integer multiple of \(2\pi\). \[e^{2\pi \xi i x} = \cos[2\pi \xi x] + i\sin[2\pi \xi x]\] Our set of eigenfunctions is therefore \(e^{2\pi \xi i x}\) for all integers \(\xi\). Diagonalizing the Laplacian Now that we’ve found suitable eigenfunctions, we can construct an orthonormal basis. Our collection of eigenfunctions is linearly independent, as each one corresponds to a distinct eigenvalue. Next, we can check for orthogonality and unit magnitude: Mutual Orthogonality Compute the inner product of \(e^{2\pi \xi_1 i x}\) and \(e^{2\pi \xi_2 i x}\) for \(\xi_1 \neq \xi_2\): \[\begin{align*} \langle e^{2\pi\xi_1 i x}, e^{2\pi\xi_2 i x} \rangle &amp;= \int_0^1 e^{2\pi\xi_1 i x} \overline{e^{2\pi\xi_2 i x}}\, dx \\ &amp;= \int_0^1 (\cos[2\pi\xi_1 x] + i\sin[2\pi\xi_1 x])(\cos[2\pi\xi_2 x] - i\sin[2\pi\xi_2 x])\, dx \\ &amp;= \int_0^1 \cos[2\pi\xi_1 x]\cos[2\pi\xi_2 x] - i\cos[2\pi\xi_1 x]\sin[2\pi\xi_2 x] +\\ &amp;\phantom{= \int_0^1} i\sin[2\pi\xi_1 x]\cos[2\pi\xi_2 x] + \sin[2\pi\xi_1 x]\sin[2\pi\xi_2 x] \, dx \\ &amp;= \int_0^1 \cos[2\pi(\xi_1-\xi_2)x] + i\sin[2\pi(\xi_1-\xi_2)x]\, dx \\ &amp;= \frac{1}{2\pi(\xi_1-\xi_2)}\left(\sin[2\pi(\xi_1-\xi_2] x)\Big|_0^1 - i\cos[2\pi(\xi_1-\xi_2) x]\Big|_0^1\right) \\ &amp;= 0 \end{align*}\] \[\begin{align*} &amp;\langle e^{2\pi\xi_1 i x}, e^{2\pi\xi_2 i x} \rangle \\ &amp;= \int_0^1 e^{2\pi\xi_1 i x} \overline{e^{2\pi\xi_2 i x}}\, dx \\ &amp;= \int_0^1 (\cos[2\pi\xi_1 x] + i\sin[2\pi\xi_1 x])\cdot\\ &amp;\hphantom{==\int_0^1}(\cos[2\pi\xi_2 x] - i\sin[2\pi\xi_2 x])\, dx \\ &amp;= \int_0^1 \cos[2\pi\xi_1 x]\cos[2\pi\xi_2 x]\, -\\ &amp;\hphantom{==\int_0^1} i\cos[2\pi\xi_1 x]\sin[2\pi\xi_2 x] +\\ &amp;\hphantom{== \int_0^1} i\sin[2\pi\xi_1 x]\cos[2\pi\xi_2 x]\, +\\ &amp;\hphantom{==\int_0^1} \sin[2\pi\xi_1 x]\sin[2\pi\xi_2 x] \, dx \\ &amp;= \int_0^1 \cos[2\pi(\xi_1-\xi_2)x]\, +\\ &amp;\hphantom{==\int_0^1} i\sin[2\pi(\xi_1-\xi_2)x]\, dx \\ &amp;= \frac{1}{2\pi(\xi_1-\xi_2)}\Big(\sin[2\pi(\xi_1-\xi_2] x)\Big|_0^1\, -\\ &amp;\hphantom{=== \frac{1}{2\pi(\xi_1-\xi_2)}} i\cos[2\pi(\xi_1-\xi_2) x]\Big|_0^1\Big) \\ &amp;= 0 \end{align*}\] Note that the final step is valid because \(\xi_1-\xi_2\) is a non-zero integer. This result also applies to any domain \([a,b]\), given functions periodic on \([a,b]\). It’s possible to further generalize to \([-\infty,\infty]\), but doing so requires a weighted inner product. Unit Magnitude It’s easy to show that all candidate functions have norm one: \[\begin{align*} \langle e^{2\pi\xi i x}, e^{2\pi\xi i x} \rangle &amp;= \int_0^1 e^{2\pi\xi i x}\overline{e^{2\pi\xi i x}} \\ &amp;= \int_0^1 e^{2\pi\xi i x}e^{-2\pi\xi i x}\, dx \\&amp;= \int_0^1 1\, dx\\ &amp;= 1 \end{align*}\] With the addition of a constant factor \(\frac{1}{b-a}\), this result generalizes to any \([a,b]\). It’s possible to further generalize to \([-\infty,\infty]\), but doing so requires a weighted inner product. The final step is to show that all functions in our domain can be represented by a linear combination of eigenfunctions. To do so, we will find an invertible operator \(\mathcal{L}\) representing the proper change of basis. Critically, since our eigenbasis is orthonormal, we can intuitively consider the inverse of \(\mathcal{L}\) to be its transpose. \[\mathcal{I} = \mathcal{L}\mathcal{L}^{-1} = \mathcal{L}\mathcal{L}^{T} = \begin{bmatrix} \vert &amp; \vert &amp; &amp; \\ e^{2\pi\xi_1 i x} &amp; e^{2\pi\xi_2 i x} &amp; \dots \\ \vert &amp; \vert &amp; \end{bmatrix}\begin{bmatrix} \text{---} &amp; e^{2\pi\xi_1 i x} &amp; \text{---} \\ \text{---} &amp; e^{2\pi\xi_2 i x} &amp; \text{---} \\ &amp; \vdots &amp; \end{bmatrix}\] \[\begin{align*} \mathcal{I} &amp;= \mathcal{L}\mathcal{L}^{-1} \\&amp;= \mathcal{L}\mathcal{L}^{T} \\&amp;= \begin{bmatrix} \vert &amp; \vert &amp; &amp; \\ e^{2\pi\xi_1 i x} &amp; e^{2\pi\xi_2 i x} &amp; \dots \\ \vert &amp; \vert &amp; \end{bmatrix}\\ &amp; \phantom{=} \begin{bmatrix} \text{---} &amp; e^{2\pi\xi_1 i x} &amp; \text{---} \\ \text{---} &amp; e^{2\pi\xi_2 i x} &amp; \text{---} \\ &amp; \vdots &amp; \end{bmatrix} \end{align*}\] This visualization suggests that \(\mathcal{L}^Tf\) computes the inner product of \(f\) with each eigenvector. \[\mathcal{L}^Tf = \begin{bmatrix}\langle f, e^{2\pi\xi_1 i x} \rangle \\ \langle f, e^{2\pi\xi_2 i x} \rangle \\ \vdots \end{bmatrix}\] Which is highly reminiscent of the finite-dimensional case, where we projected onto each eigenvector of an orthogonal eigenbasis. This insight allows us to write down the product \(\mathcal{L}^Tf\) as an integer function \(\hat{f}[\xi]\). Note that the complex inner product conjugates the second argument, so the exponent is negated. \[(\mathcal{L}^Tf)[\xi] = \hat{f}[\xi] = \int_0^1 f[x]e^{-2\pi\xi i x}\, dx\] Conversely, \(\mathcal{L}\) converts \(\hat{f}\) back to the standard basis. It simply creates a linear combination of eigenfunctions. \[(\mathcal{L}\hat{f})[x] = f[x] = \sum_{\xi=-\infty}^\infty \hat{f}[\xi] e^{2\pi\xi i x}\] These operators are, in fact, inverses of each other, but a rigorous proof is beyond the scope of this post. Therefore, we’ve diagonalized the Laplacian: \[\begin{align*} \Delta &amp;= \mathcal{L} \mathcal{D} \mathcal{L}^T \\ &amp;= \begin{bmatrix} \vert &amp; \vert &amp; &amp; \\ e^{2\pi\xi_1 i x} &amp; e^{2\pi\xi_2 i x} &amp; \dots \\ \vert &amp; \vert &amp; \end{bmatrix} \begin{bmatrix} -(2\pi\xi_1)^2 &amp; 0 &amp; \dots \\ 0 &amp; -(2\pi\xi_2)^2 &amp; \dots \\ \vdots &amp; \vdots &amp; \ddots \end{bmatrix} \begin{bmatrix} \text{---} &amp; e^{2\pi\xi_1 i x} &amp; \text{---} \\ \text{---} &amp; e^{2\pi\xi_2 i x} &amp; \text{---} \\ &amp; \vdots &amp; \end{bmatrix} \end{align*}\] \[\begin{align*} \Delta &amp;= \mathcal{L} \mathcal{D} \mathcal{L}^T \\ &amp;= \begin{bmatrix} \vert &amp; \vert &amp; &amp; \\ e^{2\pi\xi_1 i x} &amp; e^{2\pi\xi_2 i x} &amp; \dots \\ \vert &amp; \vert &amp; \end{bmatrix} \\ &amp; \phantom{=} \begin{bmatrix} -(2\pi\xi_1)^2 &amp; 0 &amp; \dots \\ 0 &amp; -(2\pi\xi_2)^2 &amp; \dots \\ \vdots &amp; \vdots &amp; \ddots \end{bmatrix} \\ &amp; \phantom{=} \begin{bmatrix} \text{---} &amp; e^{2\pi\xi_1 i x} &amp; \text{---} \\ \text{---} &amp; e^{2\pi\xi_2 i x} &amp; \text{---} \\ &amp; \vdots &amp; \end{bmatrix} \end{align*}\] Although \(\mathcal{L}^T\) transforms our real-valued function into a complex-valued function, \(\Delta\) as a whole still maps real functions to real functions. Next, we’ll see how \(\mathcal{L}^T\) is itself an incredibly useful transformation. Applications In this section, we’ll explore several applications in signal processing, each of which arises from diagonalizing the Laplacian on a new domain. Fourier Series Review: But what is a Fourier series? From heat flow to drawing with circles | DE4. If you’re familiar with Fourier methods, you likely noticed that \(\hat{f}\) encodes the Fourier series of \(f\). That’s because a Fourier transform is a change of basis into the Laplacian eigenbasis! This basis consists of waves, which makes \(\hat{f}\) is a particularly interesting representation for \(f\). For example, consider evaluating \(\hat{f}[1]\): \[\hat{f}[1] = \int_0^1 f[x] e^{-2\pi i x}\, dx = \int_0^1 f[x](\cos[2\pi x] - i\sin[2\pi x])\, dx\] \[\begin{align*} \hat{f}[1] &amp;= \int_0^1 f[x] e^{-2\pi i x}\, dx \\&amp;= \int_0^1 f[x](\cos[2\pi x] - i\sin[2\pi x])\, dx \end{align*}\] This integral measures how much of \(f\) is represented by waves of frequency (positive) 1. Naturally, \(\hat{f}[\xi]\) computes the same quantity for any integer frequency \(\xi\). \[\hphantom{aaa} {\color{#9673A6} \text{Real}\left[e^{2\pi i \xi x}\right]}\,\,\,\,\,\,\,\, {\color{#D79B00} \text{Complex}\left[e^{2\pi i \xi x}\right]}\] $$\xi = 1$$ Therefore, we say that \(\hat{f}\) expresses our function in the frequency domain. To illustrate this point, we’ll use a Fourier series to decompose a piecewise linear function into a collection of waves.8 Since our new basis is orthonormal, the transform is easy to invert by re-combining the waves. Here, the \(\color{#9673A6}\text{purple}\) curve is \(f\); the \(\color{#D79B00}\text{orange}\) curve is a reconstruction of \(f\) from the first \(N\) coefficients of \(\hat{f}\). Try varying the number of coefficients and moving the \(\color{#9673A6}\text{purple}\) dots to effect the results. $$ \hphantom{aaa} {\color{#9673A6} f[x]}\,\,\,\,\,\,\,\,\,\,\,\, {\color{#D79B00} \sum_{\xi=-N}^N \hat{f}[\xi]e^{2\pi i \xi x}} $$ $$N = 3$$ Additionally, explore the individual basis functions making up our result: $$\hat{f}[0]$$ $$\hat{f}[1]e^{2\pi i x}$$ $$\hat{f}[2]e^{4\pi i x}$$ $$\hat{f}[3]e^{6\pi i x}$$ &nbsp; Many interesting operations become easy to compute in the frequency domain. For example, by simply dropping Fourier coefficients beyond a certain threshold, we can reconstruct a smoothed version of our function. This technique is known as a low-pass filter—try it out above. Image Compression Computationally, Fourier series are especially useful for compression. Encoding a function \(f\) in the standard basis takes a lot of space, since we store a separate result for each input. If we instead express \(f\) in the Fourier basis, we only need to store a few coefficients—we’ll be able to approximately reconstruct \(f\) by re-combining the corresponding basis functions. So far, we’ve only defined a Fourier transform for functions on \(\mathbb{R}\). Luckily, the transform arose via diagonalizing the Laplacian, and the Laplacian is not limited to one-dimensional functions. In fact, wherever we can define a Laplacian, we can find a corresponding Fourier transform.9 For example, in two dimensions, the Laplacian becomes a sum of second derivatives. \[\Delta f[x,y] = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2}\] For the domain \([0,1]\times[0,1]\), we’ll find a familiar set of periodic eigenfunctions. \[e^{2\pi i(nx + my)} = \cos[2\pi(nx + my)] + i\sin[2\pi(nx + my)]\] \[\begin{align*} e^{2\pi i(nx + my)} &amp;= \cos[2\pi(nx + my)]\, + \\ &amp;\phantom{=}\, i\sin[2\pi(nx + my)] \end{align*}\] Where \(n\) and \(m\) are both integers. Let’s see what these basis functions look like: \[{\color{#9673A6} \text{Real}\left[e^{2\pi i(nx + my)}\right]}\] \[{\color{#D79B00} \text{Complex}\left[e^{2\pi i(nx + my)}\right]}\] $$n = 3$$ $$m = 3$$ Just like the 1D case, the corresponding Fourier transform is a change of basis into the Laplacian’s orthonormal eigenbasis. Above, we decomposed a 1D function into a collection of 1D waves—here, we equivalently decompose a 2D image into a collection of 2D waves. \[\phantom{\Bigg|} {\color{#9673A6} f[x,y]}\] \[{\color{#D79B00} \sum_{n=-N}^N \sum_{m=-N}^N \hat{f}[n,m]e^{2\pi i(nx + my)}}\] $$N = 3$$ A variant of the 2D Fourier transform is at the core of many image compression algorithms, including JPEG. Spherical Harmonics Computer graphics is often concerned with functions on the unit sphere, so let’s see if we can find a corresponding Fourier transform. In spherical coordinates, the Laplacian can be defined as follows: \[\Delta f(\theta, \phi) = \frac{1}{\sin[\theta]}\frac{\partial}{\partial \theta}\left(\sin[\theta] \frac{\partial f}{\partial \theta}\right) + \frac{1}{\sin^2[\theta]}\frac{\partial^2 f}{\partial \phi^2}\] \[\begin{align*} \Delta f(\theta, \phi) &amp;= \frac{1}{\sin[\theta]}\frac{\partial}{\partial \theta}\left(\sin[\theta] \frac{\partial f}{\partial \theta}\right)\, + \\ &amp;\phantom{=} \frac{1}{\sin^2[\theta]}\frac{\partial^2 f}{\partial \phi^2} \end{align*}\] We won’t go through the full derivation, but this Laplacian admits an orthornormal eigenbasis known as the spherical harmonics.10 \[Y_\ell^m[\theta, \phi] = N_\ell^m P_\ell^m[\cos[\theta]] e^{im\phi}\] Where \(Y_\ell^m\) is the spherical harmonic of degree \(\ell \ge 0\) and order \(m \in [-\ell,\ell]\). Note that \(N_\ell^m\) is a constant and \(P_\ell^m\) are the associated Legendre polynomials.11 \[\hphantom{aa} {\color{#9673A6} \text{Real}\left[Y_\ell^m[\theta,\phi]\right]}\,\,\,\,\,\,\,\, {\color{#D79B00} \text{Complex}\left[Y_\ell^m[\theta,\phi]\right]}\] $$\ell = 0$$ $$m = 0$$ As above, we define the spherical Fourier transform as a change of basis into the spherical harmonics. In game engines, this transform is often used to compress diffuse environment maps (i.e. spherical images) and global illumination probes. \[\phantom{\Bigg|} {\color{#9673A6} f[\theta,\phi]}\] \[{\color{#D79B00} \sum_{\ell=0}^N \sum_{m=-\ell}^\ell \hat{f}[\ell,m]\left( Y_\ell^m[\theta,\phi]e^{im\phi} \right)}\] $$N = 3$$ You might also recognize spherical harmonics as electron orbitals—quantum mechanics is primarily concerned with the eigenfunctions of linear operators. Geometry Processing Representing functions as vectors underlies many modern algorithms—image compression is only one example. In fact, because computers can do linear algebra so efficiently, applying linear-algebraic techniques to functions produces a powerful new computational paradigm. The nascent field of discrete differential geometry uses this perspective to build algorithms for three-dimensional geometry processing. In computer graphics, functions on meshes often represent textures, unwrappings, displacements, or simulation parameters. DDG gives us a way to faithfully encode such functions as vectors: for example, by associating a value with each vertex of the mesh. $$ \mathbf{f} = \begin{bmatrix} {\color{#666666} f_1}\\ {\color{#82B366} f_2}\\ {\color{#B85450} f_3}\\ {\color{#6C8EBF} f_4}\\ {\color{#D79B00} f_5}\\ {\color{#9673A6} f_6}\\ {\color{#D6B656} f_7}\\ \end{bmatrix} $$ One particularly relevant result is a Laplace operator for meshes. A mesh Laplacian is a finite-dimensional matrix, so we can use numerical linear algebra to find its eigenfunctions. As with the continuous case, these functions generalize sine and cosine to a new domain. Here, we visualize the real and complex parts of each eigenfunction, where the two colors indicate positive vs. negative regions. \[\hphantom{aa} {\color{#9673A6} \text{Rea}}{\color{#82B366}\text{l}\left[\psi_N\right]}\,\,\,\,\,\,\,\, {\color{#D79B00} \text{Comp}}{\color{#6C8EBF} \text{lex}\left[\psi_N\right]}\] $$4\text{th Eigenfunction}$$ At this point, the implications might be obvious—this eigenbasis is useful for transforming and compressing functions on the mesh. In fact, by interpreting the vertices’ positions as a function, we can even smooth or sharpen the geometry itself. Further Reading There’s far more to signal and geometry processing than we can cover here, let alone the many other applications in engineering, physics, and computer science. We will conclude with an (incomplete, biased) list of topics for further exploration. See if you can follow the functions-are-vectors thread throughout: Geometry: Distances, Parallel Transport, Flattening, Non-manifold Meshes, and Polygonal Meshes Simulation: the Finite Element Method, Monte Carlo PDEs, Minimal Surfaces, and Fluid Cohomology Light Transport: Radiosity, Operator Formulation (Ch.4), Low-Rank Approximation, and Inverse Rendering Machine Learning: DiffusionNet, MeshCNN, Kinematics, Fourier Features, and Inverse Geometry Splines: C2 Interpolation, Quadratic Approximation, and Simplification Thanks to Joanna Y, Hesper Yin, and Fan Pu Zeng for providing feedback on this post. Footnotes We shouldn’t assume all countably infinite-dimensional vectors represent functions on the natural numbers. Later on, we’ll discuss the space of real polynomial functions, which also has countably infinite dimensionality. &#8617; If you’re alarmed by the fact that the set of all real functions does not form a Hilbert space, you’re probably not in the target audience of this post. Don’t worry, we will later move on to \(L^2(\mathbb{R})\) and \(L^2(\mathbb{R},\mathbb{C})\). &#8617; If you’re paying close attention, you might notice that none of these proofs depended on the fact that the domain of our functions is the real numbers. In fact, the only necessary assumption is that our functions return elements of a field, allowing us to apply commutativity, associativity, etc. to the outputs. Therefore, we can define a vector space over the set of functions that map any fixed set \(\mathcal{S}\) to a field \(\mathbb{F}\). This result illustrates why we could intuitively equate finite-dimensional vectors with mappings from index to value. For example, consider \(\mathcal{S} = \{1,2,3\}\): $$ \begin{align*} f_{\mathcal{S}\mapsto\mathbb{R}} &amp;= \{ 1 \mapsto x, 2 \mapsto y, 3 \mapsto z \} \\ &amp;\vphantom{\Big|}\phantom{\,}\Updownarrow \\ f_{\mathbb{R}^3} &amp;= \begin{bmatrix}x \\ y \\ z\end{bmatrix} \end{align*} $$ If \(\mathcal{S}\) is finite, a function from \(\mathcal{S}\) to a field directly corresponds to a familiar finite-dimensional vector. &#8617; Earlier, we used countably infinite-dimensional vectors to represent functions on the natural numbers. In doing so, we implicitly employed the standard basis of impulse functions indexed by \(i \in \mathbb{N}\). Here, we encode real polynomials by choosing new basis functions of type \(\mathbb{R}\mapsto\mathbb{R}\), namely \(\mathbf{e}_i[x] = x^i\). &#8617; Since this basis spans the space of analytic functions, analytic functions have countably infinite dimensionality. Relative to the uncountably infinite-dimensional space of all real functions, analytic functions are vanishingly rare! &#8617; Actually, it states that a compact self-adjoint operator on a Hilbert space admits an orthonormal eigenbasis with real eigenvalues. Rigorously defining these terms is beyond the scope of this post, but note that our intuition about “infinite-dimensional matrices” only legitimately applies to this class of operators. &#8617; Specifically, a basis for the domain of our Laplacian, not all functions. We’ve built up several conditions that restrict our domain to square integrable, periodic, twice-differentiable real functions on \([0,1]\). &#8617; Also known as a vibe check. &#8617; Higher-dimensional Laplacians are sums of second derivatives, e.g. \(\Delta f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} + \frac{\partial^2 f}{\partial z^2}\). The Laplace-Beltrami operator expresses this sum as the divergence of the gradient, i.e. \(\Delta f = \nabla \cdot \nabla f\). Using exterior calculus, we can further generalize divergence and gradient to produce the Laplace-de Rham operator, \(\Delta f = \delta d f\), where \(\delta\) is the codifferential and \(d\) is the exterior derivative. &#8617; Typically, a “harmonic” function must satisfy \(\Delta f = 0\), but in this case we include all eigenfunctions. &#8617; The associated Legendre polynomials are closely related to the Legendre polynomials, which form a orthogonal basis for polynomials. Interestingly, they can be derived by applying the Gram–Schmidt process to the basis of powers (\(1, x, x^2, \dots\)). &#8617;]]></summary>
        <author>
            <name>Max Slater</name>
        </author>
    </entry>
</feed>